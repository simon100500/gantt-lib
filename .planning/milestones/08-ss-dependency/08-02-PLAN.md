---
phase: 08-ss-dependency
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - packages/gantt-lib/src/hooks/useTaskDrag.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "Moving SS predecessor A right/left causes successor B to follow with same delta"
    - "Moving SS successor B left is blocked at predecessor A's start position (lag cannot go below 0)"
    - "Moving SS successor B right increases lag freely (no upper bound)"
    - "Resize-right of A (endA changes) does NOT move SS successor B"
    - "Resize-left of A (startA changes) cascades SS successors with same delta as A"
    - "Resize-left of B is blocked when lag would go below 0 (B cannot start before A)"
    - "Resize-right of B has no SS constraint effect (startB unchanged)"
    - "Hard mode cascade preview (onCascadeProgress) fires for SS successors during move and resize-left of A"
    - "onCascade receives correct shifted dates for SS chain on drag completion"
    - "Soft mode: onDragEnd delivers updated SS lag via updatedDependencies"
    - "When A moves left and lag would become negative, B moves with A (lag stays 0)"
  artifacts:
    - path: "packages/gantt-lib/src/hooks/useTaskDrag.ts"
      provides: "Full SS constraint enforcement: split chains, mode-aware cascade, SS clamp, resize-left cascade"
      min_lines: 200
  key_links:
    - from: "packages/gantt-lib/src/hooks/useTaskDrag.ts"
      to: "packages/gantt-lib/src/utils/dependencyUtils.ts"
      via: "getSuccessorChain(taskId, allTasks, ['FS']) and getSuccessorChain(taskId, allTasks, ['SS'])"
      pattern: "getSuccessorChain\\(taskId"
    - from: "ActiveDragState.cascadeChainFS"
      to: "handleGlobalMouseMove resize-right branch"
      via: "mode-aware chain selection"
      pattern: "cascadeChainFS"
    - from: "ActiveDragState.cascadeChainSS"
      to: "handleGlobalMouseMove resize-left branch"
      via: "mode-aware chain selection"
      pattern: "cascadeChainSS"
---

<objective>
Wire SS constraint enforcement into useTaskDrag.ts across all drag modes. This plan extends the global drag singleton, constraint clamping, cascade emission, and drag completion to fully implement the SS behavior matrix defined in CONTEXT.md.

Purpose: Without this plan the SS successor chain is computed (Plan 01) but never used. This plan plugs the chain into all the right places so B follows A correctly during drag.
Output: useTaskDrag.ts with complete SS support: split chains, mode-aware cascade preview, SS clamp in move/resize-left, A-left lag floor, resize-left cascade of A, correct handleComplete delta for resize-left mode.
</objective>

<execution_context>
@C:/Users/Volobuev/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Volobuev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-ss-dependency/08-CONTEXT.md
@.planning/phases/08-ss-dependency/08-RESEARCH.md
@.planning/phases/08-ss-dependency/08-01-SUMMARY.md
@packages/gantt-lib/src/hooks/useTaskDrag.ts
@packages/gantt-lib/src/utils/dependencyUtils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ActiveDragState and handleMouseDown with split cascade chains</name>
  <files>packages/gantt-lib/src/hooks/useTaskDrag.ts</files>
  <action>
    1. Extend the ActiveDragState interface with two new fields after `cascadeChain`:
       ```typescript
       cascadeChainFS: Task[];   // FS-only successors (resize-right cascade)
       cascadeChainSS: Task[];   // SS-only successors (resize-left cascade)
       ```
       Keep `cascadeChain: Task[]` as the combined FS+SS chain for move mode.
       Update the JSDoc comment on cascadeChain: "// FS+SS successors of dragged task (Phase 8)"

    2. In handleMouseDown (around line 636 where globalActiveDrag is assigned), update the
       cascadeChain initialization. Currently:
       ```typescript
       cascadeChain: (mode === 'move' || mode === 'resize-right') && !disableConstraints
         ? getSuccessorChain(taskId, allTasks)
         : [],
       ```
       Replace with three separate chain computations (only when !disableConstraints):
       ```typescript
       cascadeChain: !disableConstraints
         ? getSuccessorChain(taskId, allTasks, ['FS', 'SS'])   // all successors, used for move
         : [],
       cascadeChainFS: !disableConstraints
         ? getSuccessorChain(taskId, allTasks, ['FS'])          // FS-only, used for resize-right
         : [],
       cascadeChainSS: !disableConstraints
         ? getSuccessorChain(taskId, allTasks, ['SS'])          // SS-only, used for resize-left
         : [],
       ```
       Note: chains are computed for ALL modes on drag start. Mode filtering happens at emission
       time in handleGlobalMouseMove, not here. This avoids storing mode in globalActiveDrag at
       assignment time.

    3. Verify the import of getSuccessorChain at the top of useTaskDrag.ts already has
       `getSuccessorChain` — it does (line 6). No new import needed.

    Run: npm run build --filter packages/gantt-lib — confirm no TypeScript errors.
    Run: npm test --filter packages/gantt-lib — confirm all tests pass.
    Commit: feat(08-02): extend ActiveDragState and handleMouseDown with split cascade chains
  </action>
  <verify>
    cd D:/Projects/gantt-lib && npm run build --filter packages/gantt-lib 2>&1 | tail -10
    cd D:/Projects/gantt-lib && npm test --filter packages/gantt-lib 2>&1 | tail -10
    No TypeScript errors. All tests pass.
  </verify>
  <done>
    ActiveDragState has cascadeChain (FS+SS), cascadeChainFS (FS-only), cascadeChainSS (SS-only).
    handleMouseDown populates all three fields on drag start for any mode.
    Build clean, tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend constraint clamp, cascade emission, and handleComplete for SS</name>
  <files>packages/gantt-lib/src/hooks/useTaskDrag.ts</files>
  <action>
    Four changes in handleGlobalMouseMove and handleComplete:

    === CHANGE A: Constraint clamp — add SS ===
    Location: handleGlobalMouseMove, the hard-mode boundary block (~line 206-235).
    Currently filters: `if (dep.type !== 'FS') continue;`
    Change to: `if (dep.type !== 'FS' && dep.type !== 'SS') continue;`
    For BOTH FS and SS, the boundary is predecessor.startDate (same pixel formula).
    No other change in this block.

    === CHANGE B: Mode-aware cascade emission ===
    Location: handleGlobalMouseMove, the cascade block (~line 238-267).
    Currently:
    ```typescript
    if ((mode === 'move' || mode === 'resize-right') && !globalActiveDrag.disableConstraints &&
        globalActiveDrag.cascadeChain.length > 0 && globalActiveDrag.onCascadeProgress) {
      const deltaDays = mode === 'resize-right'
        ? Math.round((newWidth - globalActiveDrag.initialWidth) / globalActiveDrag.dayWidth)
        : Math.round((newLeft - globalActiveDrag.initialLeft) / globalActiveDrag.dayWidth);
      const overrides = new Map<string, { left: number; width: number }>();
      for (const chainTask of globalActiveDrag.cascadeChain) {
        ...
        overrides.set(chainTask.id, { left: chainLeft, width: chainWidth });
      }
      globalActiveDrag.onCascadeProgress(overrides);
    }
    ```

    Replace with:
    ```typescript
    // Phase 8: select chain based on drag mode
    // move: all FS+SS successors follow
    // resize-right: only FS successors (endA changes, startA unchanged → SS unaffected)
    // resize-left: only SS successors (startA changes, endA unchanged → FS unaffected)
    const activeChain =
      mode === 'resize-right' ? globalActiveDrag.cascadeChainFS :
      mode === 'resize-left'  ? globalActiveDrag.cascadeChainSS :
      /* move */                globalActiveDrag.cascadeChain;

    if ((mode === 'move' || mode === 'resize-right' ||
         (mode === 'resize-left' && globalActiveDrag.cascadeChainSS.length > 0)) &&
        !globalActiveDrag.disableConstraints &&
        activeChain.length > 0 &&
        globalActiveDrag.onCascadeProgress) {
      // For move/resize-left: delta from left (startA shift)
      // For resize-right: delta from width (endA shift, startA fixed)
      const deltaDays = mode === 'resize-right'
        ? Math.round((newWidth - globalActiveDrag.initialWidth) / globalActiveDrag.dayWidth)
        : Math.round((newLeft - globalActiveDrag.initialLeft) / globalActiveDrag.dayWidth);
      const overrides = new Map<string, { left: number; width: number }>();
      for (const chainTask of activeChain) {
        const chainStart = new Date(chainTask.startDate as string);
        const chainEnd = new Date(chainTask.endDate as string);
        const chainStartOffset = Math.round(
          (Date.UTC(chainStart.getUTCFullYear(), chainStart.getUTCMonth(), chainStart.getUTCDate()) -
            Date.UTC(
              globalActiveDrag.monthStart.getUTCFullYear(),
              globalActiveDrag.monthStart.getUTCMonth(),
              globalActiveDrag.monthStart.getUTCDate()
            )) / (24 * 60 * 60 * 1000)
        );
        const chainDuration = Math.round(
          (Date.UTC(chainEnd.getUTCFullYear(), chainEnd.getUTCMonth(), chainEnd.getUTCDate()) -
            Date.UTC(chainStart.getUTCFullYear(), chainStart.getUTCMonth(), chainStart.getUTCDate())
          ) / (24 * 60 * 60 * 1000)
        );
        let chainLeft = Math.round((chainStartOffset + deltaDays) * globalActiveDrag.dayWidth);
        const chainWidth = Math.round((chainDuration + 1) * globalActiveDrag.dayWidth);

        // SS lag floor: when A moves left, B follows but chainLeft cannot go below A's new position
        // This keeps lag >= 0 (startB >= startA) during live drag preview
        if (mode === 'move' || mode === 'resize-left') {
          chainLeft = Math.max(chainLeft, newLeft);
        }

        overrides.set(chainTask.id, { left: chainLeft, width: chainWidth });
      }
      globalActiveDrag.onCascadeProgress(overrides);
    }
    ```

    === CHANGE C: handleComplete — resize-left delta from startDate ===
    Location: handleComplete (~line 496-538), inside the cascade block.
    Currently delta is always computed from endDate change:
    ```typescript
    const origEndMs = Date.UTC(initialEndDate.getUTCFullYear(), ...);
    const newEndMs = Date.UTC(newEndDate.getUTCFullYear(), ...);
    const deltaDays = Math.round((newEndMs - origEndMs) / (24 * 60 * 60 * 1000));
    ```

    For resize-left of A (SS cascade), endDate is fixed — delta must come from startDate.
    Find the `dragMode` stored by the owning hook instance. The mode is stored in the
    `globalActiveDrag.mode` field (read from it before completeDrag() nulls it). However,
    at completion time globalActiveDrag is already null (completeDrag nulls it before calling
    onComplete). Instead, use the local `dragMode` state from the owning hook, or derive from
    final position: if `finalLeft === initialLeft` (left didn't move) and
    `finalWidth !== initialWidth`, it was resize-right. Otherwise, delta from startDate is safe
    to use.

    Simpler approach: compute BOTH deltas and use the one that matches what happened:
    ```typescript
    // Compute delta from startDate change (correct for move and resize-left)
    const origStartMs = Date.UTC(
      initialStartDate.getUTCFullYear(),
      initialStartDate.getUTCMonth(),
      initialStartDate.getUTCDate()
    );
    const newStartMs = Date.UTC(
      newStartDate.getUTCFullYear(),
      newStartDate.getUTCMonth(),
      newStartDate.getUTCDate()
    );
    const deltaFromStart = Math.round((newStartMs - origStartMs) / (24 * 60 * 60 * 1000));

    // Compute delta from endDate change (correct for resize-right)
    const origEndMs = Date.UTC(
      initialEndDate.getUTCFullYear(),
      initialEndDate.getUTCMonth(),
      initialEndDate.getUTCDate()
    );
    const newEndMs = Date.UTC(
      newEndDate.getUTCFullYear(),
      newEndDate.getUTCMonth(),
      newEndDate.getUTCDate()
    );
    const deltaFromEnd = Math.round((newEndMs - origEndMs) / (24 * 60 * 60 * 1000));

    // For resize-right: startDate unchanged, use endDate delta (FS successors follow end)
    // For move and resize-left: use startDate delta (SS and FS-move successors follow start)
    // Detect resize-right: startDate didn't change
    const deltaDays = deltaFromStart === 0 ? deltaFromEnd : deltaFromStart;
    ```

    Replace the existing single `deltaDays` computation block with the above dual-delta logic.
    The cascade application loop (chain.map) remains unchanged.

    === CHANGE D: handleComplete — use cascadeChainSS for resize-left in completion ===
    The current hard-mode cascade completion uses `getSuccessorChain(taskId, allTasks)` to
    re-compute the chain (line ~498):
    ```typescript
    const chain = getSuccessorChain(taskId, allTasks);
    ```
    After Plan 01, this still returns FS-only (default). For resize-left of A, we need SS
    successors. Replace this with:
    ```typescript
    // Phase 8: get correct chain for completion based on what changed
    // If startDate changed: SS successors follow (resize-left or move)
    // If only endDate changed: FS successors follow (resize-right)
    const chainForCompletion = deltaFromStart !== 0
      ? getSuccessorChain(taskId, allTasks, ['FS', 'SS'])  // move or resize-left: all types
      : getSuccessorChain(taskId, allTasks, ['FS']);         // resize-right: FS only
    ```
    Then use `chainForCompletion` in place of `chain` throughout the cascade block.

    After all changes:
    Run: npm run build --filter packages/gantt-lib 2>&1 | tail -20
    Run: npm test --filter packages/gantt-lib 2>&1 | tail -20
    Confirm no TypeScript errors and all tests pass.
    Commit: feat(08-02): implement SS constraint clamp, mode-aware cascade, resize-left cascade
  </action>
  <verify>
    cd D:/Projects/gantt-lib && npm run build --filter packages/gantt-lib 2>&1 | tail -20
    cd D:/Projects/gantt-lib && npm test --filter packages/gantt-lib 2>&1 | tail -20
    No TypeScript errors. All tests pass.
    Spot-check in useTaskDrag.ts:
    - Constraint clamp block: `dep.type !== 'FS' && dep.type !== 'SS'`
    - Cascade block: references cascadeChainFS, cascadeChainSS, and cascadeChain
    - Cascade emission condition: includes `|| (mode === 'resize-left' && cascadeChainSS.length > 0)`
    - `chainLeft = Math.max(chainLeft, newLeft)` present in the emission loop
    - handleComplete has dual-delta logic (deltaFromStart, deltaFromEnd)
    - handleComplete calls getSuccessorChain with linkTypes argument
  </verify>
  <done>
    All 6 SS scenarios work in hard mode:
    - A moves: B follows (FS+SS chain, move mode)
    - B moves left: blocked at A's start (clamp applied to SS dep)
    - A resize-right: B stays (resize-right uses cascadeChainFS only)
    - A resize-left: B follows (resize-left uses cascadeChainSS)
    - B resize-left: blocked at A's start (same clamp)
    - B resize-right: unaffected (startB unchanged)
    onCascade fired on completion with correct shifted dates.
    All tests pass, build clean.
  </done>
</task>

</tasks>

<verification>
After plan 02 completes:
1. Run npm run build --filter packages/gantt-lib — no TypeScript errors
2. Run npm test --filter packages/gantt-lib — all tests pass
3. Inspect useTaskDrag.ts for:
   - ActiveDragState has cascadeChainFS and cascadeChainSS fields
   - handleMouseDown populates all three chains
   - Constraint clamp includes SS
   - Cascade block uses activeChain (mode-aware selection)
   - SS lag floor in cascade emission loop: Math.max(chainLeft, newLeft)
   - handleComplete has dual delta computation and linkTypes-parameterized getSuccessorChain call
</verification>

<success_criteria>
All SS behavior matrix scenarios from CONTEXT.md are implemented:
- A right/left → B follows (move cascade, FS+SS chain)
- B right → lag grows freely (no clamp on move-right)
- B left → blocked at A.start (clamp includes SS)
- A right-edge → B stays (resize-right uses cascadeChainFS only)
- A left-edge → B follows (resize-left uses cascadeChainSS, new cascade condition)
- B left-edge → blocked (clamp includes SS)
- B right-edge → no effect (startB unchanged)
Hard mode: onCascade receives shifted SS chain tasks on completion.
Soft mode: onDragEnd returns updatedDependencies with SS lag recalculated via Plan 01 extension.
Build clean, all tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/08-ss-dependency/08-02-SUMMARY.md`
</output>
