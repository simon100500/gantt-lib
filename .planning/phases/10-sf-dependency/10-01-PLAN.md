---
phase: 10-sf-dependency
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/gantt-lib/src/hooks/useTaskDrag.ts
  - packages/website/src/app/page.tsx
autonomous: false
requirements: []
user_setup: []

must_haves:
  truths:
    - "When SF predecessor A is moved, SF successor B follows synchronously (lag preserved)"
    - "When SF predecessor A is resized-left (startA changes), SF successor B follows synchronously"
    - "When SF predecessor A is resized-right (endA changes), SF successor B stays stationary"
    - "When SF successor B is moved right, it stops at startA (lag ceiling at 0)"
    - "When SF successor B is resized-right, its endB cannot push past startA"
    - "SF lag is recalculated on drag completion using formula: lag = endB - startA (ceiling at 0)"
    - "Cascade chains include SF for move and resize-left modes (startA changes affect B)"
  artifacts:
    - path: "packages/gantt-lib/src/hooks/useTaskDrag.ts"
      provides: "SF constraint enforcement, cascade chains, and lag recalculation"
      exports: ["ActiveDragState", "useTaskDrag"]
    - path: "packages/website/src/app/page.tsx"
      provides: "SF demo tasks showing elevator equipment delivery scenario"
      contains: "SF dependency examples"
  key_links:
    - from: "packages/gantt-lib/src/hooks/useTaskDrag.ts"
      to: "getSuccessorChain"
      via: "getTransitiveCascadeChain with ['SF'] or ['SS', 'SF']"
      pattern: "getTransitiveCascadeChain.*\['SF'\]"
    - from: "packages/gantt-lib/src/hooks/useTaskDrag.ts"
      to: "recalculateIncomingLags"
      via: "SF case handling lag = endB - startA with ceiling at 0"
      pattern: "dep\.type === 'SF'"
    - from: "packages/website/src/app/page.tsx"
      to: "gantt-lib"
      via: "Task with SF dependencies"
      pattern: "type: 'SF'"

---

<objective>
Implement SF (Start-to-Finish) dependency constraint enforcement — successor B's finish date is constrained relative to predecessor A's start date (endB = startA + lag, lag <= 0). This completes the four link type coverage (FS/SS/FF/SF) and enables supply chain and preparation task scenarios where preparatory work must be ready by the time main work begins.

Purpose: Enable realistic construction scheduling where preparation tasks (like equipment delivery) must be completed before main work (like installation) begins, with proper cascade behavior and constraint enforcement.

Output: Working SF drag constraints with cascade preview, lag recalculation, and demo tasks.
</objective>

<execution_context>
@C:/Users/Volobuev/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Volobuev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/10-sf-dependency/10-CONTEXT.md
@.planning/phases/10-sf-dependency/10-RESEARCH.md
@.planning/phases/09-ff-dependency/09-03-SUMMARY.md

# Reference implementation patterns
@packages/gantt-lib/src/hooks/useTaskDrag.ts
@packages/gantt-lib/src/utils/dependencyUtils.ts
@packages/website/src/app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Extend useTaskDrag with SF cascade chains and constraint enforcement</name>
  <files>packages/gantt-lib/src/hooks/useTaskDrag.ts</files>
  <action>
Extend useTaskDrag.ts to support SF dependency constraints. Follow the exact patterns from Phase 9 (FF) and Phase 8 (SS).

**Step 1: Extend ActiveDragState interface (around line 80-100)**
- Change `cascadeChainSS` comment to "SS+SF successors (resize-left cascade) — Phase 10: add SF"
- Add `cascadeChainStart: Task[];` field to replace cascadeChainSS (renaming for clarity: SS+SF)

**Step 2: Update handleMouseDown to populate SF chains (around line 766-794)**
- Update `cascadeChain` to include SF: `['FS', 'SS', 'FF', 'SF']` (move mode includes all types)
- Replace `cascadeChainSS` with `cascadeChainStart` using `['SS', 'SF']` (resize-left mode)
- Update `cascadeChainEnd` comment to clarify FS+FF only (SF excluded for resize-right)

**Step 3: Add SF constraint clamp in handleGlobalMouseMove (after line 278, before cascade emission)**
Add a NEW constraint block for SF (separate from FS/SS clamp because SF affects width, not left):

```typescript
// SF constraint: endB <= startA (lag ceiling at 0)
// Applies when B is moved right or resized-right
if ((mode === 'move' || mode === 'resize-right') && allTasks.length > 0 && !globalActiveDrag.disableConstraints) {
  const currentTask = allTasks.find(t => t.id === globalActiveDrag?.taskId);
  if (currentTask && currentTask.dependencies && currentTask.dependencies.length > 0) {
    for (const dep of currentTask.dependencies) {
      if (dep.type !== 'SF') continue;
      const predecessor = globalActiveDrag.allTasks.find(t => t.id === dep.taskId);
      if (!predecessor) continue;
      const predStart = new Date(predecessor.startDate as string);
      const predStartOffset = Math.round(
        (Date.UTC(predStart.getUTCFullYear(), predStart.getUTCMonth(), predStart.getUTCDate()) -
          Date.UTC(globalActiveDrag.monthStart.getUTCFullYear(), globalActiveDrag.monthStart.getUTCMonth(), globalActiveDrag.monthStart.getUTCDate()))
        / (24 * 60 * 60 * 1000)
      );
      const predStartLeft = Math.round(predStartOffset * globalActiveDrag.dayWidth);
      const currentEndRight = newLeft + newWidth;
      const maxAllowedEndRight = predStartLeft;  // endB cannot exceed startA
      if (currentEndRight > maxAllowedEndRight) {
        // Clamp width so endB = startA
        newWidth = Math.max(globalActiveDrag.dayWidth, maxAllowedEndRight - newLeft);
      }
    }
  }
}
```

**Step 4: Update cascade chain selection (around line 280-287)**
Change from:
```typescript
const activeChain =
  mode === 'resize-right' ? globalActiveDrag.cascadeChainEnd :   // FS + FF
  mode === 'resize-left'  ? globalActiveDrag.cascadeChainSS :    // SS only
  /* move */                globalActiveDrag.cascadeChain;         // FS + SS + FF
```

To:
```typescript
const activeChain =
  mode === 'resize-right' ? globalActiveDrag.cascadeChainEnd :    // FS + FF
  mode === 'resize-left'  ? globalActiveDrag.cascadeChainStart :  // SS + SF
  /* move */                globalActiveDrag.cascadeChain;         // FS + SS + FF + SF
```

**Step 5: Update cascade emission condition (around line 290-294)**
Change condition from `globalActiveDrag.cascadeChainSS.length > 0` to `globalActiveDrag.cascadeChainStart.length > 0`

**Step 6: Extend recalculateIncomingLags with SF case (around line 199-208)**
Replace the simplified lag=0 function with full implementation:

```typescript
function recalculateIncomingLags(
  task: Task,
  newStartDate: Date,
  newEndDate: Date,
  allTasks: Task[]
): NonNullable<Task['dependencies']> {
  if (!task.dependencies) return [];
  const taskById = new Map(allTasks.map(t => [t.id, t]));

  return task.dependencies.map(dep => {
    if (dep.type === 'FS') {
      // FS: lag = startB - endA (can be negative)
      const predecessor = taskById.get(dep.taskId);
      if (!predecessor) return dep;
      const predEnd = new Date(predecessor.endDate as string);
      const lagMs = Date.UTC(newStartDate.getUTCFullYear(), newStartDate.getUTCMonth(), newStartDate.getUTCDate())
                  - Date.UTC(predEnd.getUTCFullYear(), predEnd.getUTCMonth(), predEnd.getUTCDate());
      const lagDays = Math.round(lagMs / (24 * 60 * 60 * 1000));
      return { ...dep, lag: lagDays };
    }
    if (dep.type === 'SS') {
      // SS: lag = startB - startA (floor at 0)
      const predecessor = taskById.get(dep.taskId);
      if (!predecessor) return dep;
      const predStart = new Date(predecessor.startDate as string);
      const lagMs = Date.UTC(newStartDate.getUTCFullYear(), newStartDate.getUTCMonth(), newStartDate.getUTCDate())
                  - Date.UTC(predStart.getUTCFullYear(), predStart.getUTCMonth(), predStart.getUTCDate());
      const lagDays = Math.max(0, Math.round(lagMs / (24 * 60 * 60 * 1000))); // SS: floor at 0
      return { ...dep, lag: lagDays };
    }
    if (dep.type === 'FF') {
      // FF: lag = endB - endA (can be negative)
      const predecessor = taskById.get(dep.taskId);
      if (!predecessor) return dep;
      const predEnd = new Date(predecessor.endDate as string);
      const lagMs = Date.UTC(newEndDate.getUTCFullYear(), newEndDate.getUTCMonth(), newEndDate.getUTCDate())
                  - Date.UTC(predEnd.getUTCFullYear(), predEnd.getUTCMonth(), predEnd.getUTCDate());
      const lagDays = Math.round(lagMs / (24 * 60 * 60 * 1000));
      return { ...dep, lag: lagDays };
    }
    if (dep.type === 'SF') {
      // SF: lag = endB - startA (ceiling at 0)
      const predecessor = taskById.get(dep.taskId);
      if (!predecessor) return dep;
      const predStart = new Date(predecessor.startDate as string);
      const lagMs = Date.UTC(newEndDate.getUTCFullYear(), newEndDate.getUTCMonth(), newEndDate.getUTCDate())
                  - Date.UTC(predStart.getUTCFullYear(), predStart.getUTCMonth(), predStart.getUTCDate());
      const lagDays = Math.min(0, Math.round(lagMs / (24 * 60 * 60 * 1000))); // SF: ceiling at 0
      return { ...dep, lag: lagDays };
    }
    return dep;
  });
}
```

**Step 7: Update chain selection in handleComplete (around line 638-642)**
Change from:
```typescript
const chainForCompletion = deltaFromStart === 0
  ? getTransitiveCascadeChain(taskId, allTasks, ['FS', 'FF'])          // resize-right: FS + FF
  : isResizeLeft
    ? getTransitiveCascadeChain(taskId, allTasks, ['SS'])               // resize-left: SS only
    : getTransitiveCascadeChain(taskId, allTasks, ['FS', 'SS', 'FF']); // move: all types
```

To:
```typescript
const chainForCompletion = deltaFromStart === 0
  ? getTransitiveCascadeChain(taskId, allTasks, ['FS', 'FF'])               // resize-right: FS + FF
  : isResizeLeft
    ? getTransitiveCascadeChain(taskId, allTasks, ['SS', 'SF'])             // resize-left: SS + SF
    : getTransitiveCascadeChain(taskId, allTasks, ['FS', 'SS', 'FF', 'SF']); // move: all types
```

**Key implementation notes:**
- SF cascade behavior is identical to SS (both depend on startA)
- SF constraint clamp affects width (not left) because it constrains endB
- SF lag uses Math.min(0, ...) for ceiling (opposite of SS's Math.max(0, ...))
- SF lag formula uses newEndDate (like FF) but anchored to predStart (like SS)
</action>
  <verify>Build completes: `npm run build --workspace=packages/gantt-lib`</verify>
  <done>
- ActiveDragState includes cascadeChainStart (SS+SF for resize-left)
- handleMouseDown populates all cascade chains including SF
- SF constraint clamp blocks B from moving past startA (endB <= startA)
- Cascade chains include SF for move and resize-left modes
- recalculateIncomingLags handles SF case with ceiling at 0
- handleComplete uses SF-aware chain selection
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>SF constraint enforcement implementation with cascade chains, constraint clamp, and lag recalculation</what-built>
  <how-to-verify>
1. Start the dev server: `npm run dev --workspace=packages/website`
2. Open http://localhost:3000
3. Add SF demo tasks to the Construction Project (next task will add these)
4. Test SF behaviors:
   - Move predecessor A left/right → successor B should follow
   - Resize-left A (startA changes) → B should follow
   - Resize-right A (endA changes) → B should NOT move
   - Move B right → should stop at startA (lag = 0 ceiling)
   - Resize-right B → endB should not push past startA
   - Resize-left B → should move freely (only affects startB)
5. Check console for any errors
6. Verify lag values are correct after soft-mode drags
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

<task type="auto">
  <name>Add SF demo tasks to Construction Project</name>
  <files>packages/website/src/app/page.tsx</files>
  <action>
Add SF dependency demo tasks to the Construction Project in page.tsx. Add these tasks after the existing tasks (around line 210, before the closing of createSampleTasks).

Add the following SF demo tasks:

```typescript
    // === SF ДЕМО: ЛИФТОВАЯ ОБОРУДОВАНИЕ ===
    {
      id: "sf-1",
      name: "Установка лифта (SF predecessor)",
      startDate: addDays(baseDate, 150),
      endDate: addDays(baseDate, 165),
      color: "#3b82f6",
      progress: 0,
    },
    {
      id: "sf-2",
      name: "Поставка лифтового оборудования (SF successor)",
      startDate: addDays(baseDate, 105),
      endDate: addDays(baseDate, 150), // 45 дней на логистику
      color: "#10b981",
      progress: 0,
      dependencies: [
        { taskId: 'sf-1', type: 'SF', lag: 0 }
      ],
    },
```

These tasks demonstrate the key SF behavior: when "Установка лифта" (installation) shifts left, "Поставка лифтового оборудования" (delivery) pulls in — showing that the order must be placed earlier when logistics take longer.
</action>
  <verify>Page loads without errors, SF demo tasks appear in the chart</verify>
  <done>SF demo tasks added showing elevator equipment delivery scenario with SF dependency</done>
</task>

</tasks>

<verification>
After completing all tasks, verify the following SF behaviors work correctly:

1. **Cascade from predecessor A:**
   - Move A left/right → B follows (lag preserved)
   - Resize-left A (startA changes) → B follows
   - Resize-right A (endA changes) → B stationary

2. **Constraint enforcement on successor B:**
   - Move B right → stops at startA (lag ceiling at 0)
   - Resize-right B → endB cannot push past startA
   - Resize-left B → moves freely (only affects startB)

3. **Lag recalculation:**
   - SF lag formula: lag = endB - startA (ceiling at 0)
   - After soft-mode drag, lag is correctly persisted
   - Lag never exceeds 0 (Math.min(0, ...) enforcement)

4. **Visual feedback:**
   - Cascade preview shows B moving during A drag
   - Constraint clamp prevents B from moving past startA
   - Dependency line renders correctly (Quick-17 already handles SF)

5. **Demo tasks:**
   - Elevator equipment delivery scenario is visible
   - All SF interaction scenarios are testable
</verification>

<success_criteria>
SF dependency constraint enforcement is complete when:
- User can drag SF predecessor A and SF successor B follows in move/resize-left modes
- User cannot drag SF successor B past startA (constraint clamp works)
- SF lag is correctly recalculated and persisted after drag completion
- Cascade chains include SF for appropriate modes (move, resize-left)
- SF demo tasks demonstrate the elevator equipment delivery scenario
- All four link types (FS/SS/FF/SF) work correctly in the Construction Project
</success_criteria>

<output>
After completion, create `.planning/phases/10-sf-dependency/10-01-SUMMARY.md`
</output>
