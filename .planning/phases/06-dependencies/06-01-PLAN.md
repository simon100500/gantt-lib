---
phase: 06-dependencies
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/gantt-lib/src/types/index.ts
  - packages/gantt-lib/src/utils/dependencyUtils.ts
  - packages/gantt-lib/src/utils/geometry.ts
  - packages/gantt-lib/src/utils/index.ts
autonomous: true
requirements: [INT-05]

must_haves:
  truths:
    - "Developer can define task dependencies with 4 link types (FS, SS, FF, SF) and lag values"
    - "Circular dependencies are detected and reported with cycle path"
    - "Dependency constraints are validated against task dates"
    - "Helper functions calculate expected successor dates based on link type and lag"
  artifacts:
    - path: "packages/gantt-lib/src/types/index.ts"
      provides: "Dependency type definitions (LinkType, TaskDependency, DependencyError, ValidationResult)"
      contains: "LinkType, TaskDependency, DependencyError, ValidationResult"
      min_lines: 30
    - path: "packages/gantt-lib/src/utils/dependencyUtils.ts"
      provides: "Cycle detection and dependency validation utilities"
      exports: ["detectCycles", "validateDependencies", "calculateSuccessorDate", "buildAdjacencyList"]
      min_lines: 80
    - path: "packages/gantt-lib/src/utils/geometry.ts"
      provides: "Bezier curve calculation for dependency lines"
      exports: ["calculateBezierPath"]
      min_lines: 20
    - path: "packages/gantt-lib/src/utils/index.ts"
      provides: "Utility exports including new dependencyUtils"
      contains: "dependencyUtils"
  key_links:
    - from: "packages/gantt-lib/src/types/index.ts"
      to: "Task interface"
      via: "Extended with optional dependencies?: TaskDependency[] property"
      pattern: "dependencies\\?:\\s*TaskDependency\\[\\]"
    - from: "packages/gantt-lib/src/utils/dependencyUtils.ts"
      to: "Task type"
      via: "Imported type for cycle detection and validation"
      pattern: "import.*Task.*from.*types"
---

<objective>
Extend Task type with dependency definitions and implement core dependency utilities including cycle detection, link type date calculations, and constraint validation.

**Purpose:** Enable tasks to define predecessor relationships with support for all four PM link types (FS, SS, FF, SF), lag values, and automatic detection of circular dependencies.

**Output:**
- Extended Task interface with dependencies array
- DependencyUtils module with DFS-based cycle detection
- Link type date calculation functions
- Bezier curve path calculation for future visualization
- TypeScript types for validation errors
</objective>

<execution_context>
@C:/Users/Volobuev/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Volobuev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-dependencies/06-CONTEXT.md
@.planning/phases/06-dependencies/06-RESEARCH.md

# Prior phases for patterns reference
@.planning/phases/01-foundation-core-rendering/01-02-SUMMARY.md
@.planning/phases/02-drag-and-drop-interactions/02-03-SUMMARY.md

# Current codebase patterns
@packages/gantt-lib/src/types/index.ts
@packages/gantt-lib/src/utils/geometry.ts
@packages/gantt-lib/src/utils/dateUtils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependency type definitions to types/index.ts</name>
  <files>packages/gantt-lib/src/types/index.ts</files>
  <action>
Add the following type definitions to packages/gantt-lib/src/types/index.ts (after existing Task interface, before other interfaces):

```typescript
/**
 * Dependency link types following PM standard
 * - FS (Finish-to-Start): Predecessor must finish before successor starts
 * - SS (Start-to-Start): Predecessor must start before successor starts
 * - FF (Finish-to-Finish): Predecessor must finish before successor finishes
 * - SF (Start-to-Finish): Predecessor must start before successor finishes
 */
export type LinkType = 'FS' | 'SS' | 'FF' | 'SF';

/**
 * Single dependency relationship (predecessor link)
 */
export interface TaskDependency {
  /** ID of the predecessor task */
  taskId: string;
  /** Type of link: FS (finish-to-start), SS, FF, SF */
  type: LinkType;
  /** Lag in days (positive or negative integer, default: 0) */
  lag?: number;
}

/**
 * Error or warning from dependency validation
 */
export interface DependencyError {
  /** Type of error */
  type: 'cycle' | 'constraint' | 'missing-task';
  /** ID of the task with the error */
  taskId: string;
  /** Human-readable error message */
  message: string;
  /** Related task IDs (e.g., cycle path, referenced tasks) */
  relatedTaskIds?: string[];
}

/**
 * Result of dependency validation
 */
export interface ValidationResult {
  /** True if no errors found */
  isValid: boolean;
  /** Array of errors/warnings (empty if valid) */
  errors: DependencyError[];
}
```

Then extend the Task interface by adding after the `accepted` property:
```typescript
  /**
   * Optional array of predecessor dependencies
   * Each dependency specifies a predecessor task, link type, and optional lag
   */
  dependencies?: TaskDependency[];
```

**Important:** Do NOT modify existing properties - only add the new `dependencies?` property.
  </action>
  <verify>
Run `npx tsc --noEmit` from packages/gantt-lib to verify no TypeScript errors.
  </verify>
  <done>
Task interface includes optional dependencies?: TaskDependency[] property, and all new types (LinkType, TaskDependency, DependencyError, ValidationResult) are exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dependencyUtils.ts with cycle detection and validation</name>
  <files>packages/gantt-lib/src/utils/dependencyUtils.ts</files>
  <action>
Create new file packages/gantt-lib/src/utils/dependencyUtils.ts with the following implementation:

```typescript
import { Task, TaskDependency, LinkType, ValidationResult, DependencyError } from '../types';

/**
 * Build adjacency list for dependency graph (task -> successors)
 */
export function buildAdjacencyList(tasks: Task[]): Map<string, string[]> {
  const taskMap = new Map(tasks.map(t => [t.id, t]));
  const graph = new Map<string, string[]>();

  for (const task of tasks) {
    const successors: string[] = [];

    // Find all tasks that depend on this task (this task is a predecessor)
    for (const otherTask of tasks) {
      if (otherTask.dependencies) {
        for (const dep of otherTask.dependencies) {
          if (dep.taskId === task.id) {
            successors.push(otherTask.id);
            break;
          }
        }
      }
    }

    graph.set(task.id, successors);
  }

  return graph;
}

/**
 * Detect circular dependencies using depth-first search
 */
export function detectCycles(tasks: Task[]): { hasCycle: boolean; cyclePath?: string[] } {
  const graph = buildAdjacencyList(tasks);
  const visiting = new Set<string>();
  const visited = new Set<string>();
  const path: string[] = [];

  function dfs(taskId: string): boolean {
    if (visiting.has(taskId)) {
      // Found cycle - current task is already in recursion stack
      return true;
    }
    if (visited.has(taskId)) {
      return false;
    }

    visiting.add(taskId);
    path.push(taskId);

    const successors = graph.get(taskId) || [];
    for (const successor of successors) {
      if (dfs(successor)) {
        return true;
      }
    }

    visiting.delete(taskId);
    path.pop();
    visited.add(taskId);
    return false;
  }

  for (const task of tasks) {
    if (dfs(task.id)) {
      return { hasCycle: true, cyclePath: [...path] };
    }
  }

  return { hasCycle: false };
}

/**
 * Calculate successor date based on predecessor dates, link type, and lag
 *
 * Link type semantics:
 * - FS: Successor start = Predecessor end + lag
 * - SS: Successor start = Predecessor start + lag
 * - FF: Successor end = Predecessor end + lag
 * - SF: Successor end = Predecessor start + lag
 */
export function calculateSuccessorDate(
  predecessorStart: Date,
  predecessorEnd: Date,
  linkType: LinkType,
  lag: number = 0
): Date {
  // Base date: predecessor end for F* types, predecessor start for S* types
  const baseDate = linkType.startsWith('F') ? predecessorEnd : predecessorStart;

  // Apply lag (in days, converted to milliseconds)
  const lagMs = lag * 24 * 60 * 60 * 1000;
  const resultDate = new Date(baseDate.getTime() + lagMs);

  return resultDate;
}

/**
 * Validate all dependencies in the task list
 */
export function validateDependencies(tasks: Task[]): ValidationResult {
  const errors: DependencyError[] = [];
  const taskIds = new Set(tasks.map(t => t.id));

  // Check for missing predecessor references
  for (const task of tasks) {
    if (task.dependencies) {
      for (const dep of task.dependencies) {
        if (!taskIds.has(dep.taskId)) {
          errors.push({
            type: 'missing-task',
            taskId: task.id,
            message: `Dependency references non-existent task: ${dep.taskId}`,
            relatedTaskIds: [dep.taskId],
          });
        }
      }
    }
  }

  // Check for cycles
  const cycleResult = detectCycles(tasks);
  if (cycleResult.hasCycle && cycleResult.cyclePath) {
    errors.push({
      type: 'cycle',
      taskId: cycleResult.cyclePath[0],
      message: 'Circular dependency detected',
      relatedTaskIds: cycleResult.cyclePath,
    });
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}

/**
 * Get all dependency edges for rendering
 * Returns array of { predecessorId, successorId, type, lag }
 */
export function getAllDependencyEdges(tasks: Task[]): Array<{
  predecessorId: string;
  successorId: string;
  type: LinkType;
  lag: number;
}> {
  const edges: Array<{ predecessorId: string; successorId: string; type: LinkType; lag: number }> = [];

  for (const task of tasks) {
    if (task.dependencies) {
      for (const dep of task.dependencies) {
        edges.push({
          predecessorId: dep.taskId,
          successorId: task.id,
          type: dep.type,
          lag: dep.lag ?? 0,
        });
      }
    }
  }

  return edges;
}
```

**Key patterns to follow from existing codebase:**
- Use UTC-safe Date arithmetic (pattern from dateUtils.ts)
- Round pixel values with Math.round() for clean rendering (pattern from geometry.ts)
- Return simple, testable data structures (pattern from existing utils)
  </action>
  <verify>
1. Run `npx tsc --noEmit` from packages/gantt-lib to verify TypeScript compilation
2. Run `npm test` to ensure existing tests still pass
  </verify>
  <done>
dependencyUtils.ts file exists with all exported functions (buildAdjacencyList, detectCycles, calculateSuccessorDate, validateDependencies, getAllDependencyEdges), TypeScript compiles without errors, and existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Bezier curve calculation to geometry.ts and export dependencyUtils</name>
  <files>packages/gantt-lib/src/utils/geometry.ts,packages/gantt-lib/src/utils/index.ts</files>
  <action>
First, add the Bezier curve calculation function to packages/gantt-lib/src/utils/geometry.ts (at end of file, before export):

```typescript
/**
 * Calculate SVG cubic Bezier curve path for dependency lines
 * @param from - Start point {x, y} (right edge of predecessor)
 * @param to - End point {x, y} (left edge of successor)
 * @returns SVG path string for cubic Bezier curve
 */
export const calculateBezierPath = (
  from: { x: number; y: number },
  to: { x: number; y: number }
): string => {
  // Control points create smooth vertical curve
  // Offset is proportional to vertical distance for natural-looking curves
  const verticalDistance = Math.abs(to.y - from.y);
  const cpOffset = Math.max(verticalDistance * 0.5, 20); // Minimum 20px for same-row connections

  // For same-row connections, use arc above the task bars
  if (from.y === to.y) {
    const arcHeight = 20;
    const midX = (from.x + to.x) / 2;
    return `M ${from.x} ${from.y} Q ${midX} ${from.y - arcHeight} ${to.x} ${to.y}`;
  }

  // Standard cubic Bezier for multi-row connections
  const cp1x = from.x;
  const cp1y = from.y + (to.y > from.y ? cpOffset : -cpOffset);
  const cp2x = to.x;
  const cp2y = to.y - (to.y > from.y ? cpOffset : -cpOffset);

  return `M ${Math.round(from.x)} ${Math.round(from.y)} C ${Math.round(cp1x)} ${Math.round(cp1y)}, ${Math.round(cp2x)} ${Math.round(cp2y)}, ${Math.round(to.x)} ${Math.round(to.y)}`;
};
```

**Important:** Use Math.round() for all coordinates to avoid sub-pixel rendering issues (following existing geometry.ts pattern).

Second, update packages/gantt-lib/src/utils/index.ts to export dependencyUtils:
Add to the export statement:
```typescript
export * from './dependencyUtils';
```

If the file uses individual exports, add:
```typescript
export {
  buildAdjacencyList,
  detectCycles,
  calculateSuccessorDate,
  validateDependencies,
  getAllDependencyEdges,
} from './dependencyUtils';
```

And ensure calculateBezierPath is exported from geometry exports.
  </action>
  <verify>
Run `npx tsc --noEmit` from packages/gantt-lib to verify no TypeScript errors.
  </verify>
  <done>
calculateBezierPath function is exported from geometry.ts, dependencyUtils functions are exported from utils/index.ts, and TypeScript compilation succeeds.
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. TypeScript compiles without errors: `npx tsc --noEmit` from packages/gantt-lib
2. All existing tests pass: `npm test`
3. New types can be imported: `import { TaskDependency, LinkType } from 'gantt-lib/types'`
4. New utilities can be imported: `import { validateDependencies } from 'gantt-lib/utils'`
</verification>

<success_criteria>
1. Task interface extended with dependencies?: TaskDependency[] property
2. All four link types (FS, SS, FF, SF) defined as LinkType union type
3. detectCycles() function correctly identifies circular dependencies
4. calculateSuccessorDate() applies link type logic with lag support
5. validateDependencies() returns ValidationResult with errors array
6. calculateBezierPath() generates SVG path strings for dependency visualization
7. All new exports available from gantt-lib package
8. Zero TypeScript errors, zero breaking changes to existing API
</success_criteria>

<output>
After completion, create `.planning/phases/06-dependencies/06-01-SUMMARY.md`
</output>
