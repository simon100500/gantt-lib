---
phase: 06-dependencies
plan: 03
type: execute
wave: 3
depends_on: ["06-01", "06-02"]
files_modified:
  - packages/gantt-lib/src/components/GanttChart/GanttChart.tsx
  - packages/gantt-lib/src/components/GanttChart/GanttChart.css
  - packages/gantt-lib/src/hooks/useTaskDrag.ts
autonomous: true
requirements: [INT-05, INT-06]

must_haves:
  truths:
    - "DependencyLines component is rendered within GanttChart task area"
    - "Drag operations are validated against dependency constraints"
    - "Move operations that violate dependencies are blocked (resize is allowed)"
    - "Optional auto-schedule mode shifts dependent tasks when predecessor moves"
    - "onValidateDependencies callback provides validation results to parent"
    - "Dependency lines scroll with grid content"
  artifacts:
    - path: "packages/gantt-lib/src/components/GanttChart/GanttChart.tsx"
      provides: "GanttChart with dependency lines and validation integration"
      contains: "DependencyLines, enableAutoSchedule, onValidateDependencies"
      min_lines: 20
    - path: "packages/gantt-lib/src/components/GanttChart/GanttChart.css"
      provides: "Styles for dependency lines integration"
    - path: "packages/gantt-lib/src/hooks/useTaskDrag.ts"
      provides: "useTaskDrag with dependency constraint validation"
      contains: "validateConstraints, canMoveTask"
      min_lines: 50
  key_links:
    - from: "GanttChart.tsx"
      to: "DependencyLines"
      via: "Imported and rendered within task area"
      pattern: "import.*DependencyLines.*from.*DependencyLines"
    - from: "GanttChart.tsx"
      to: "validateDependencies"
      via: "Imported for validation callback"
      pattern: "import.*validateDependencies.*from.*dependencyUtils"
    - from: "useTaskDrag.ts"
      to: "Task interface"
      via: "Extended to check dependencies during drag validation"
      pattern: "dependencies.*validation"
    - from: "useTaskDrag.ts"
      to: "calculateSuccessorDate"
      via: "Imported for constraint validation"
      pattern: "import.*calculateSuccessorDate.*from.*dependencyUtils"
---

<objective>
Integrate DependencyLines component into GanttChart and add dependency constraint validation to drag operations.

**Purpose:** Enable GanttChart to display dependency lines and enforce dependency constraints during task movement, with optional auto-schedule mode for shifting dependent tasks.

**Output:**
- GanttChart renders DependencyLines overlay within task area
- Drag operations validate against predecessor dependencies
- Move operations blocked when constraints would be violated (resize allowed per spec)
- Optional enableAutoSchedule prop for automatic dependent task shifting
- onValidateDependencies callback exposes validation results to parent
- Dependency lines scroll synchronously with grid content
</objective>

<execution_context>
@C:/Users/Volobuev/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Volobuev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-dependencies/06-CONTEXT.md
@.planning/phases/06-dependencies/06-RESEARCH.md

# Prior plans - foundation for integration
@.planning/phases/06-dependencies/06-01-PLAN.md
@.planning/phases/06-dependencies/06-02-PLAN.md

# Codebase integration patterns
@.planning/phases/02-drag-and-drop-interactions/02-03-SUMMARY.md
@.planning/phases/03-calendar/03-04-SUMMARY.md
@packages/gantt-lib/src/components/GanttChart/GanttChart.tsx
@packages/gantt-lib/src/hooks/useTaskDrag.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend GanttChart with DependencyLines and validation props</name>
  <files>packages/gantt-lib/src/components/GanttChart/GanttChart.tsx,packages/gantt-lib/src/components/GanttChart/GanttChart.css</files>
  <action>
Update GanttChart component to integrate DependencyLines and validation:

**Changes to GanttChart.tsx:**

1. Add new imports:
```typescript
import DependencyLines from '../DependencyLines';
import { validateDependencies } from '../../utils/dependencyUtils';
import { ValidationResult } from '../../types';
```

2. Extend GanttChartProps interface (add after containerHeight):
```typescript
  /** Optional callback for dependency validation results */
  onValidateDependencies?: (result: ValidationResult) => void;
  /** Enable automatic shifting of dependent tasks when predecessor moves (default: false) */
  enableAutoSchedule?: boolean;
```

3. Add state for validation results (after existing dragGuideLines state):
```typescript
  const [validationResult, setValidationResult] = useState<ValidationResult | null>(null);
```

4. Update validation when tasks change (add after existing useMemo calls):
```typescript
  // Validate dependencies when tasks change
  useEffect(() => {
    const result = validateDependencies(tasks);
    setValidationResult(result);
    onValidateDependencies?.(result);
  }, [tasks, onValidateDependencies]);
```

5. Add DependencyLines component in task area (after DragGuideLines, before TaskRow loop):
```typescript
          {/* Dependency lines SVG overlay */}
          <DependencyLines
            tasks={tasks}
            monthStart={monthStart}
            dayWidth={dayWidth}
            rowHeight={rowHeight}
            gridWidth={gridWidth}
          />
```

6. Pass enableAutoSchedule to TaskRow (update TaskRow props):
```typescript
          {tasks.map((task, index) => (
            <TaskRow
              key={task.id}
              task={task}
              monthStart={monthStart}
              dayWidth={dayWidth}
              rowHeight={rowHeight}
              onChange={handleTaskChange}
              onDragStateChange={handleDragStateChange}
              rowIndex={index}
              allTasks={tasks}
              enableAutoSchedule={enableAutoSchedule ?? false}
            />
          ))}
```

**Changes to GanttChart.css:**

No changes needed - DependencyLines uses absolute positioning within task area.

**Important:** Follow existing patterns:
- Use useCallback for onChange (already exists, reuse pattern)
- Use useEffect for side effects (validation notification)
- Maintain existing component structure and prop order
  </action>
  <verify>
Run `npx tsc --noEmit` from packages/gantt-lib to verify no TypeScript errors.
  </verify>
  <done>
GanttChart imports DependencyLines, renders it in task area, exposes enableAutoSchedule and onValidateDependencies props, and TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend useTaskDrag with dependency constraint validation</name>
  <files>packages/gantt-lib/src/hooks/useTaskDrag.ts</files>
  <action>
Update useTaskDrag hook to validate dependency constraints during drag:

**Changes to useTaskDrag.ts:**

1. Add imports (after existing imports):
```typescript
import { Task, TaskDependency } from '../types';
import { calculateSuccessorDate } from '../utils/dependencyUtils';
```

2. Extend UseTaskDragOptions interface (add after edgeZoneWidth):
```typescript
  /** Array of all tasks for dependency validation */
  allTasks?: Task[];
  /** Row index of this task (for task lookup) */
  rowIndex?: number;
  /** Enable automatic scheduling of dependent tasks */
  enableAutoSchedule?: boolean;
```

3. Add helper function to check if move is allowed (after snapToGrid function):
```typescript
/**
 * Check if a task move would violate dependency constraints
 * Only blocks move operations, not resize (per requirements)
 */
function canMoveTask(
  task: Task,
  newStartDate: Date,
  newEndDate: Date,
  allTasks: Task[]
): { allowed: boolean; reason?: string } {
  if (!task.dependencies || task.dependencies.length === 0) {
    return { allowed: true };
  }

  // For each predecessor, check if the new position respects the constraint
  for (const dep of task.dependencies) {
    const predecessor = allTasks.find(t => t.id === dep.taskId);
    if (!predecessor) continue;

    const predecessorStart = new Date(predecessor.startDate);
    const predecessorEnd = new Date(predecessor.endDate);

    // Calculate expected date based on link type
    const expectedDate = calculateSuccessorDate(
      predecessorStart,
      predecessorEnd,
      dep.type,
      dep.lag ?? 0
    );

    // Check constraint based on link type
    const targetIsStart = dep.type.endsWith('S');
    const targetDate = targetIsStart ? newStartDate : newEndDate;

    // Allow move if target date is on or after expected date
    // (give 1-day tolerance for rounding)
    const dayDiff = (targetDate.getTime() - expectedDate.getTime()) / (24 * 60 * 60 * 1000);

    if (dayDiff < -1) {
      return {
        allowed: false,
        reason: `Would violate ${dep.type} dependency from "${predecessor.name}"`
      };
    }
  }

  return { allowed: true };
}

/**
 * Calculate shifted dates for dependent tasks (auto-schedule)
 */
function calculateDependentShifts(
  movedTask: Task,
  originalStart: Date,
  originalEnd: Date,
  newStart: Date,
  newEnd: Date,
  allTasks: Task[]
): Array<{ taskId: string; startDate: Date; endDate: Date }> {
  const shifts: Array<{ taskId: string; startDate: Date; endDate: Date }> = [];
  const visited = new Set<string>();

  // Calculate time delta
  const startDelta = newStart.getTime() - originalStart.getTime();
  const endDelta = newEnd.getTime() - originalEnd.getTime();

  function shiftTask(taskId: string) {
    if (visited.has(taskId)) return;
    visited.add(taskId);

    // Find all tasks that depend on this task
    for (const task of allTasks) {
      if (!task.dependencies) continue;

      const hasDepOnMovedTask = task.dependencies.some(d => d.taskId === taskId);
      if (!hasDepOnMovedTask) continue;

      // Calculate shift based on link type
      for (const dep of task.dependencies) {
        if (dep.taskId !== taskId) continue;

        const taskStart = new Date(task.startDate);
        const taskEnd = new Date(task.endDate);

        let newTaskStart = taskStart;
        let newTaskEnd = taskEnd;

        // Apply shift based on which end of predecessor is relevant
        if (dep.type.startsWith('F')) {
          // Predecessor finish affects successor
          newTaskEnd = new Date(taskEnd.getTime() + endDelta);
          // Keep duration same, shift start
          const duration = taskEnd.getTime() - taskStart.getTime();
          newTaskStart = new Date(newTaskEnd.getTime() - duration);
        } else {
          // Predecessor start affects successor
          newTaskStart = new Date(taskStart.getTime() + startDelta);
          // Keep duration same, shift end
          const duration = taskEnd.getTime() - taskStart.getTime();
          newTaskEnd = new Date(newTaskStart.getTime() + duration);
        }

        shifts.push({
          taskId: task.id,
          startDate: newTaskStart,
          endDate: newTaskEnd,
        });

        // Recursively shift dependents
        shiftTask(task.id);
      }
    }
  }

  shiftTask(movedTask.id);
  return shifts;
}
```

4. Update handleGlobalMouseMove to validate constraints (inside the RAF callback, before updating currentLeft/currentWidth):
```typescript
    const { allTasks = [], taskId, mode, enableAutoSchedule = false } = globalActiveDrag;

    // For move operations, check dependency constraints
    if (mode === 'move' && allTasks.length > 0) {
      const currentTask = allTasks.find(t => t.id === taskId);
      if (currentTask) {
        const originalStart = new Date(currentTask.startDate);
        const originalEnd = new Date(currentTask.endDate);

        // Calculate new dates
        const dayOffset = Math.round(newLeft / globalActiveDrag.dayWidth);
        const durationDays = Math.round(newWidth / globalActiveDrag.dayWidth) - 1;
        const monthStart = globalActiveDrag.monthStart;

        const newStartDate = new Date(Date.UTC(
          monthStart.getUTCFullYear(),
          monthStart.getUTCMonth(),
          monthStart.getUTCDate() + dayOffset
        ));

        const newEndDate = new Date(Date.UTC(
          monthStart.getUTCFullYear(),
          monthStart.getUTCMonth(),
          monthStart.getUTCDate() + dayOffset + durationDays
        ));

        // Check constraints
        const validation = canMoveTask(currentTask, newStartDate, newEndDate, allTasks);
        if (!validation.allowed) {
          // Revert to initial position - block the move
          newLeft = globalActiveDrag.initialLeft;
          newWidth = globalActiveDrag.initialWidth;
        }
      }
    }
```

**Note:** This is a simplified validation approach. For production, you may want to:
- Add visual feedback when move is blocked
- Show tooltip with reason for blocking
- Make the blocking behavior configurable

For this plan, blocking the move (reverting position) satisfies the requirement.
  </action>
  <verify>
Run `npx tsc --noEmit` from packages/gantt-lib to verify no TypeScript errors.
  </verify>
  <done>
useTaskDrag validates dependency constraints during move operations, blocks moves that violate constraints (allows resize), and TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update TaskRow to receive and pass dependency props to useTaskDrag</name>
  <files>packages/gantt-lib/src/components/TaskRow/TaskRow.tsx</files>
  <action>
Update TaskRow component to pass dependency-related props to useTaskDrag:

**Changes to TaskRow.tsx:**

1. Extend TaskRowProps interface (add after existing props):
```typescript
  /** Row index for dependency lookup */
  rowIndex?: number;
  /** All tasks for dependency validation */
  allTasks?: Task[];
  /** Enable automatic scheduling of dependent tasks */
  enableAutoSchedule?: boolean;
```

2. Update useTaskDrag call (add new props):
```typescript
  const { isDragging, dragMode, currentLeft, currentWidth, dragHandleProps } = useTaskDrag({
    taskId: task.id,
    initialStartDate: new Date(task.startDate),
    initialEndDate: new Date(task.endDate),
    monthStart,
    dayWidth,
    onDragEnd: handleDragEnd,
    onDragStateChange,
    edgeZoneWidth,
    allTasks,
    rowIndex,
    enableAutoSchedule,
  });
```

**Important:** Maintain existing prop order and component structure. Only add the new props.
  </action>
  <verify>
Run `npx tsc --noEmit` from packages/gantt-lib to verify no TypeScript errors.
  </verify>
  <done>
TaskRow passes rowIndex, allTasks, and enableAutoSchedule props to useTaskDrag, and TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. TypeScript compiles without errors: `npx tsc --noEmit` from packages/gantt-lib
2. All existing tests pass: `npm test`
3. GanttChart can receive enableAutoSchedule and onValidateDependencies props
4. TaskRow receives new props without breaking existing usage
5. Dependency lines are rendered in GanttChart task area
</verification>

<success_criteria>
1. DependencyLines component is rendered within GanttChart task area
2. Drag operations validate against dependency constraints
3. Move operations that violate dependencies are blocked (revert to original position)
4. Resize operations are NOT blocked by dependencies (per requirements)
5. enableAutoSchedule prop is available (implementation placeholder for future)
6. onValidateDependencies callback provides validation results to parent
7. Dependency lines scroll with grid content (absolute positioning)
8. Zero breaking changes to existing API (all new props are optional)
9. TypeScript compiles without errors, all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-dependencies/06-03-SUMMARY.md`
</output>
