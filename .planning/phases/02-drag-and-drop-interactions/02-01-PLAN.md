---
phase: 02-drag-and-drop-interactions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/index.ts
  - src/hooks/useTaskDrag.ts
  - src/utils/geometry.ts
  - src/utils/index.ts
autonomous: true
requirements:
  - INT-01
  - INT-02
  - QL-02
must_haves:
  truths:
    - "Custom useTaskDrag hook manages drag state via refs (not React state) to prevent re-renders during dragging"
    - "Hook supports both move (entire bar) and resize (left/right edge) modes based on cursor position"
    - "Event listeners attached to window for reliable drag completion detection"
    - "Edge zone detection (10-15px) determines resize vs move intent"
    - "useEffect cleanup function removes window event listeners to prevent memory leaks"
  artifacts:
    - path: "src/hooks/index.ts"
      provides: "Hook barrel export"
      exports: ["useTaskDrag"]
    - path: "src/hooks/useTaskDrag.ts"
      provides: "Custom drag hook with refs for performance"
      min_lines: 150
      contains: "useRef for drag state"
    - path: "src/utils/geometry.ts"
      provides: "Edge detection helpers"
      exports: ["detectEdgeZone", "getCursorForPosition"]
  key_links:
    - from: "src/hooks/useTaskDrag.ts"
      to: "window"
      via: "addEventListener('mousemove', ...) and addEventListener('mouseup', ...)"
      pattern: "window\.addEventListener"
    - from: "src/hooks/useTaskDrag.ts"
      to: "src/utils/geometry.ts"
      via: "import { detectEdgeZone, getCursorForPosition }"
      pattern: "detectEdgeZone|getCursorForPosition"
---

# Plan 02-01: Drag State Management and Hit Detection

## Objective

Create a custom `useTaskDrag` hook that manages all drag interaction state using refs (not React state) to prevent re-render storms during drag operations. The hook must support both move (entire bar) and resize (left/right edge) modes, with edge zone detection to determine user intent.

**Purpose:** Establish the drag interaction foundation with 60fps performance by avoiding React state updates during drag, using refs for high-frequency position tracking, and requestAnimationFrame for smooth visual updates.

**Output:** A reusable `useTaskDrag` hook with edge detection utilities that can be integrated into TaskRow component.

## Execution Context

@C:/Users/Volobuev/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Volobuev/.claude/get-shit-done/templates/summary.md

## Context

@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-drag-and-drop-interactions/02-CONTEXT.md
@.planning/phases/02-drag-and-drop-interactions/02-RESEARCH.md
@.planning/phases/01-foundation-core-rendering/01-02-SUMMARY.md
@.planning/phases/01-foundation-core-rendering/01-03-SUMMARY.md

@src/components/TaskRow/TaskRow.tsx
@src/utils/geometry.ts
@src/utils/dateUtils.ts

## Tasks

<task type="auto">
  <name>Task 1: Create hooks directory and barrel export</name>
  <files>src/hooks/index.ts</files>
  <action>
    Create src/hooks/ directory if it doesn't exist. Create src/hooks/index.ts with barrel export for useTaskDrag hook (will be created in Task 2). This follows the established pattern from src/components/index.ts and src/utils/index.ts.

    File structure:
    - src/hooks/index.ts: Export all hooks from the directory
  </action>
  <verify>File exists at src/hooks/index.ts with empty export array (to be populated in Task 2)</verify>
  <done>src/hooks/index.ts created with export structure ready for useTaskDrag</done>
</task>

<task type="auto">
  <name>Task 2: Add edge detection utilities to geometry.ts</name>
  <files>src/utils/geometry.ts</files>
  <action>
    Add edge detection helper functions to src/utils/geometry.ts. These functions determine if cursor is on left edge, right edge, or middle of task bar for resize vs move intent.

    Add these functions:

    1. `detectEdgeZone(clientX: number, taskBarElement: HTMLElement, edgeZoneWidth: number): 'left' | 'right' | 'move'`
       - Calculates cursor position relative to task bar
       - Returns 'left' if within edgeZoneWidth pixels of left edge
       - Returns 'right' if within edgeZoneWidth pixels of right edge
       - Returns 'move' otherwise
       - Uses getBoundingClientRect() for element position

    2. `getCursorForPosition(position: 'left' | 'right' | 'move'): string`
       - Returns 'ew-resize' for left/right edges
       - Returns 'grab' for move position
       - Returns 'default' for any other input

    Follow existing geometry.ts patterns: TypeScript strict types, Math.round for pixel calculations, JSDoc comments.

    IMPORTANT: Use 12px as default edgeZoneWidth (within 10-15px range per user decision).
  </action>
  <verify>npm test passes with existing geometry tests; TypeScript compilation succeeds</verify>
  <done>geometry.ts exports detectEdgeZone and getCursorForPosition functions with proper TypeScript types</done>
</task>

<task type="auto">
  <name>Task 3: Create useTaskDrag custom hook</name>
  <files>src/hooks/useTaskDrag.ts</files>
  <action>
    Create src/hooks/useTaskDrag.ts implementing the custom drag hook. Use refs (not state) for drag position to prevent re-renders. Use requestAnimationFrame for smooth 60fps updates. Attach event listeners to window (not element) to prevent cursor slip.

    Interface definition:
    ```typescript
    export interface UseTaskDragOptions {
      taskId: string;
      initialStartDate: Date;
      initialEndDate: Date;
      monthStart: Date;
      dayWidth: number;
      onDragEnd?: (result: { id: string; startDate: Date; endDate: Date }) => void;
      edgeZoneWidth?: number;
    }

    export interface UseTaskDragReturn {
      isDragging: boolean;
      dragMode: 'move' | 'resize-left' | 'resize-right' | null;
      currentLeft: number;
      currentWidth: number;
      dragHandleProps: {
        onMouseDown: (e: React.MouseEvent) => void;
        style: React.CSSProperties;
      };
    }
    ```

    Implementation requirements:
    1. Use useRef for all high-frequency state (isDragging, startX, initialLeft, initialWidth, dragMode)
    2. Use useState only for isDragging boolean (triggers event listener attachment)
    3. Use useRef for position updates (currentLeft, currentWidth) to avoid re-renders
    4. Use requestAnimationFrame in handleMouseMove to batch visual updates
    5. Snap to grid: Math.round(pixels / dayWidth) * dayWidth
    6. Minimum width: dayWidth (1 day minimum per user decision)
    7. Edge detection: Call detectEdgeZone from geometry.ts in onMouseDown
    8. Mouse events on window: Add listeners in useEffect when isDragging=true
    9. Cleanup: Remove listeners in useEffect return function, cancel RAF
    10. onDragEnd callback: Convert final pixels back to dates using Date.UTC

    Date conversion (pixel to date):
    ```typescript
    const pixelToDate = (pixels: number, baseDate: Date): Date => {
      const dayOffset = Math.round(pixels / dayWidth);
      return new Date(Date.UTC(
        baseDate.getUTCFullYear(),
        baseDate.getUTCMonth(),
        baseDate.getUTCDate() + dayOffset
      ));
    };
    ``    Handle three drag modes:
    - 'move': Both left and width change (entire bar moves)
    - 'resize-left': left changes, width adjusts to keep right edge fixed
    - 'resize-right': Only width changes (left edge fixed)

    IMPORTANT: Do NOT create DragTooltip component yet - that's Plan 02-02.
    IMPORTANT: Do NOT integrate with TaskRow yet - that's Plan 02-02.
  </action>
  <verify>TypeScript compilation succeeds with no errors; src/hooks/index.ts exports useTaskDrag</verify>
  <done>useTaskDrag hook created with refs-based state management, RAF batching, window event listeners, and cleanup</done>
</task>

## Verification

Run these checks after completion:
1. TypeScript compilation: `npx tsc --noEmit` - must have no errors
2. Existing tests still pass: `npm test` - all 36 geometry/dateUtils tests pass
3. File exists check: `ls src/hooks/useTaskDrag.ts` - hook file created
4. Export check: `grep -r "useTaskDrag" src/hooks/index.ts` - barrel exports hook
5. Geometry export check: `grep -r "detectEdgeZone\|getCursorForPosition" src/utils/geometry.ts` - functions added

## Success Criteria

- [ ] Custom useTaskDrag hook created with refs-based drag state management
- [ ] Edge detection utilities added to geometry.ts (detectEdgeZone, getCursorForPosition)
- [ ] Hook supports move, resize-left, and resize-right modes
- [ ] Event listeners attached to window with proper cleanup in useEffect
- [ ] requestAnimationFrame used for smooth 60fps visual updates
- [ ] Snap-to-grid calculation implemented (Math.round)
- [ ] Minimum 1-day width constraint enforced
- [ ] TypeScript strict mode compilation succeeds
- [ ] All existing tests (36) still pass
- [ ] No new dependencies added (uses existing stack only)

## Output

After completion, create `.planning/phases/02-drag-and-drop-interactions/02-01-SUMMARY.md` following the summary template.
