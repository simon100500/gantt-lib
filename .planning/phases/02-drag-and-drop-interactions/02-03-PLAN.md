---
phase: 02-drag-and-drop-interactions
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/components/TaskRow/TaskRow.tsx
  - src/components/TaskRow/TaskRow.module.css
  - src/__tests__/useTaskDrag.test.ts
autonomous: true
requirements:
  - INT-03
  - QL-01
must_haves:
  truths:
    - "TaskRow maintains React.memo optimization to prevent re-render storms during drag"
    - "Drag state is isolated to individual task rows (dragging one task doesn't re-render others)"
    - "Component maintains 60fps performance with ~100 tasks during drag operations"
    - "useTaskDrag hook unit tests cover edge cases and cleanup scenarios"
    - "CSS transitions disabled during active drag to prevent lag/ghosting"
  artifacts:
    - path: "src/components/TaskRow/TaskRow.tsx"
      provides: "Optimized task row with React.memo"
      contains: "React.memo"
    - path: "src/components/TaskRow/TaskRow.module.css"
      provides: "Performance-optimized styles"
      contains: "transition: none"
    - path: "src/__tests__/useTaskDrag.test.ts"
      provides: "Unit tests for drag hook"
      min_lines: 100
      contains: "describe('useTaskDrag'"
  key_links:
    - from: "src/components/TaskRow/TaskRow.tsx"
      to: "React"
      via: "React.memo with custom comparison function"
      pattern: "React\.memo"
    - from: "src/__tests__/useTaskDrag.test.ts"
      to: "src/hooks/useTaskDrag.ts"
      via: "import { useTaskDrag, renderHook } from '@testing-library/react'"
      pattern: "useTaskDrag|renderHook"
---

# Plan 02-03: Performance Optimization and Testing

## Objective

Optimize drag performance to maintain 60fps with ~100 tasks. Verify React.memo prevents re-render storms during drag. Isolate drag state to individual task rows. Add unit tests for useTaskDrag hook covering edge cases, cleanup, and interactions.

**Purpose:** Ensure smooth 60fps performance during drag operations even with 100 tasks, prevent memory leaks, and verify drag behavior with comprehensive tests.

**Output:** Performance-optimized drag interactions with React.memo isolation, disabled CSS transitions during drag, and unit tests covering drag hook behavior.

## Execution Context

@C:/Users/Volobuev/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Volobuev/.claude/get-shit-done/templates/summary.md

## Context

@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-drag-and-drop-interactions/02-CONTEXT.md
@.planning/phases/02-drag-and-drop-interactions/02-RESEARCH.md
@.planning/phases/02-drag-and-drop-interactions/02-01-SUMMARY.md
@.planning/phases/02-drag-and-drop-interactions/02-02-SUMMARY.md
@.planning/phases/01-foundation-core-rendering/01-03-SUMMARY.md

@src/components/TaskRow/TaskRow.tsx
@src/hooks/useTaskDrag.ts
@src/__tests__/geometry.test.ts

## Tasks

<task type="auto">
  <name>Task 1: Optimize React.memo comparison to prevent re-render storms</name>
  <files>src/components/TaskRow/TaskRow.tsx</files>
  <action>
    Update the React.memo comparison function in TaskRow to ensure that dragging one task doesn't cause other tasks to re-render. The comparison must properly handle the new drag-related props.

    Current arePropsEqual checks: task.id, task.name, task.startDate, task.endDate, task.color, dayWidth, rowHeight

    Add to comparison:
    - onChange prop (function reference comparison - may cause issues, handle carefully)

    Performance strategy:
    1. Use useCallback for onChange in parent component (GanttChart) to maintain referential equality
    2. Update arePropsEqual to skip onChange comparison if it's a stable reference
    3. Ensure useTaskDrag doesn't cause parent re-renders (uses refs internally)

    In GanttChart.tsx:
    - Wrap onChange callback in useCallback before passing to TaskRow
    - This ensures onChange prop reference is stable across renders

    In TaskRow arePropsEqual:
    - Add onChange to comparison OR remove onChange from comparison (if using useCallback in parent)
    - Document the decision in JSDoc comments

    Alternative approach: Remove onChange from arePropsEqual if using useCallback in parent (function reference is stable).

    Per research: "React.memo on task components to prevent re-render storms" is critical for 60fps performance with 100 tasks.

    Choose ONE approach:
    A) Add onChange to arePropsEqual (reference equality)
    B) Remove onChange from arePropsEqual (assume parent uses useCallback)

    RECOMMENDED: Use approach B (remove onChange from comparison) and implement useCallback in GanttChart.
  </action>
  <verify>TypeScript compilation succeeds; console shows no re-render warnings during drag in React DevTools</verify>
  <done>React.memo comparison optimized; GanttChart uses useCallback for onChange; TaskRow re-renders isolated to dragged task only</done>
</task>

<task type="auto">
  <name>Task 2: Disable CSS transitions during active drag</name>
  <files>src/components/TaskRow/TaskRow.module.css</files>
  <action>
    Ensure CSS transitions are disabled during active drag to prevent lag/ghosting. The .dragging class should have `transition: none` or `transition: none !important`.

    Verify existing styles from Plan 02-02:
    - .taskBar.dragging has transition: none
    - If missing, add: `transition: none !important;`

    Also verify hover states have transitions (for smooth hover effect):
    - .taskBar:hover should have `transition: box-shadow 0.15s ease` or similar
    - This provides smooth hover animation but disables during drag

    Per research anti-pattern: "Using CSS transitions during drag causes lag/ghosting."

    Also verify transform is not used (use left/width directly):
    - DragTooltip and task bar should use left/top for positioning
    - Avoid transform: translate() during drag (can cause stuttering)

    If any transition properties exist on .dragging class, remove them.
  </action>
  <verify>CSS file has .dragging class with transition: none; hover states have transitions</verify>
  <done>TaskRow.module.css disables transitions during drag, enables transitions for hover</done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for useTaskDrag hook</name>
  <files>src/__tests__/useTaskDrag.test.ts</files>
  <action>
    Create comprehensive unit tests for useTaskDrag hook using @testing-library/react's renderHook function. Test edge cases, cleanup scenarios, and drag behavior.

    Test file: src/__tests__/useTaskDrag.test.ts

    Test cases to include:

    1. Initialization:
       - Hook returns initial state (isDragging=false, currentLeft=0, etc.)
       - dragHandleProps contains onMouseDown function

    2. Edge detection:
       - MouseDown on left edge triggers resize-left mode
       - MouseDown on right edge triggers resize-right mode
       - MouseDown on center triggers move mode

    3. Move operation:
       - Moving task updates currentLeft while maintaining width
       - Snapping to grid: position rounds to nearest dayWidth
       - onDragEnd called with correct date offsets

    4. Resize operation:
       - Resizing left edge updates left and width
       - Resizing right edge updates width only
       - Minimum width enforced (1 day / dayWidth)
       - onDragEnd called with updated duration

    5. Event listener cleanup:
       - useEffect cleanup removes window event listeners
       - RAF callbacks cancelled on cleanup
       - No memory leaks after multiple drag cycles

    6. Boundary cases:
       - Drag to negative position (before month start)
       - Drag beyond visible grid
       - Zero duration task (start=end)
       - Minimum width enforcement

    Use renderHook from @testing-library/react for hook testing.
    Use jest.useFakeTimers() or vi.useFakeTimers() for RAF testing if needed.
    Mock window.addEventListener/removeEventListener to verify cleanup.

    Per planning patterns: TDD workflow, comprehensive edge case coverage, follow existing test structure from geometry.test.ts.

    IMPORTANT: These are UNIT TESTS for the hook logic, not integration tests. Test drag calculations, not actual DOM manipulation.
  </action>
  <verify>npm test passes with new useTaskDrag tests; all tests pass (existing + new)</verify>
  <done>useTaskDrag.test.ts created with comprehensive test coverage for hook behavior, edge cases, and cleanup</done>
</task>

<task type="auto">
  <name>Task 4: Performance verification with 100 tasks</name>
  <files>src/app/page.tsx</files>
  <action>
    Update demo page to include 100 sample tasks for performance verification. This allows manual testing of 60fps performance requirement.

    Update src/app/page.tsx:
    1. Generate 100 tasks programmatically
    2. Distribute tasks across the month
    3. Vary task durations (1-5 days)
    4. Use different colors for visual variety

    Example generation code:
    ```typescript
    const generate100Tasks = (): Task[] => {
      const tasks: Task[] = [];
      for (let i = 0; i < 100; i++) {
        const startDay = Math.floor(Math.random() * 25); // Days 0-24
        const duration = Math.floor(Math.random() * 5) + 1; // 1-5 days
        tasks.push({
          id: `task-${i}`,
          name: `Task ${i + 1}`,
          startDate: new Date(Date.UTC(2026, 1, startDay + 1)).toISOString(),
          endDate: new Date(Date.UTC(2026, 1, startDay + duration)).toISOString(),
          color: i % 3 === 0 ? '#3b82f6' : i % 3 === 1 ? '#10b981' : undefined,
        });
      }
      return tasks;
    };
    ```

    Keep original 7-task example for clarity (add as separate section or comment).

    Add performance testing instructions in comments:
    - Open Chrome DevTools Performance tab
    - Start recording
    - Drag a task for 5 seconds
    - Stop recording
    - Verify FPS stays near 60fps
    - Check for long tasks (>16.6ms indicates frame drops)

    Per requirement INT-03: "Component maintains 60fps performance during drag operations (~100 tasks)."
  </action>
  <verify>Page loads with 100 tasks; dev server runs without errors; performance testing instructions added</verify>
  <done>Demo page includes 100 generated tasks for performance verification</done>
</task>

## Verification

Run these checks after completion:
1. All tests pass: `npm test` - including new useTaskDrag tests
2. TypeScript compilation: `npx tsc --noEmit` - no errors
3. Build succeeds: `npm run build` - production build completes
4. Performance test: Open dev server, drag task in 100-task view, verify smooth 60fps in DevTools Performance tab
5. Memory leak test: Drag 20+ tasks consecutively, verify no memory increase in Chrome DevTools Memory profiler

## Success Criteria

- [ ] React.memo comparison optimized to prevent non-dragged tasks from re-rendering
- [ ] GanttChart uses useCallback for onChange to maintain referential equality
- [ ] CSS transitions disabled during active drag (.dragging class)
- [ ] useTaskDrag unit tests cover initialization, edge detection, move, resize, cleanup, and boundaries
- [ ] All tests pass (existing 36 + new useTaskDrag tests)
- [ ] Demo page includes 100 tasks for performance testing
- [ ] Manual verification shows 60fps performance during drag with 100 tasks
- [ ] No memory leaks detected after multiple drag operations
- [ ] Event listeners properly cleaned up (verified in tests)

## Output

After completion, create `.planning/phases/02-drag-and-drop-interactions/02-03-SUMMARY.md` following the summary template.
