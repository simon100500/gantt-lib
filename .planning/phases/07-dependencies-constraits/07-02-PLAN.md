---
phase: 07-dependencies-constraits
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - packages/gantt-lib/src/components/TaskRow/TaskRow.tsx
  - packages/gantt-lib/src/components/GanttChart/GanttChart.tsx
  - packages/website/src/app/page.tsx
autonomous: false
requirements: [PHASE7-WIRING]

must_haves:
  truths:
    - "GanttChart has cascadeOverrides state and passes overridePosition to each TaskRow"
    - "TaskRow renders at overridePosition when set, otherwise at its own drag/static position"
    - "arePropsEqual in TaskRow includes overridePosition in comparison (chain tasks re-render during drag)"
    - "GanttChart accepts onCascade prop and threads it through to useTaskDrag via TaskRow"
    - "Demo page shows cascade moving: dragging parent task visually shifts all FS successor bars in real time"
    - "onCascade callback receives all shifted tasks including the dragged one"
    - "Soft mode: after drag, task's dependency lag values are updated in state via onChange"
  artifacts:
    - path: "packages/gantt-lib/src/components/GanttChart/GanttChart.tsx"
      provides: "cascadeOverrides state, handleCascadeProgress, onCascade prop"
      contains: "cascadeOverrides|onCascade|handleCascadeProgress"
    - path: "packages/gantt-lib/src/components/TaskRow/TaskRow.tsx"
      provides: "overridePosition prop with arePropsEqual comparison"
      contains: "overridePosition"
    - path: "packages/website/src/app/page.tsx"
      provides: "Demo showing cascade drag with onCascade handler"
      contains: "onCascade"
  key_links:
    - from: "GanttChart.tsx"
      to: "TaskRow overridePosition"
      via: "cascadeOverrides.get(task.id) passed as overridePosition prop"
      pattern: "cascadeOverrides\\.get"
    - from: "GanttChart.tsx"
      to: "useTaskDrag onCascadeProgress"
      via: "handleCascadeProgress passed through TaskRow to useTaskDrag"
      pattern: "handleCascadeProgress|onCascadeProgress"
    - from: "TaskRow displayLeft/displayWidth"
      to: "overridePosition"
      via: "overridePosition?.left ?? (isDragging ? currentLeft : left)"
      pattern: "overridePosition"
---

<objective>
Wire cascade overrides from useTaskDrag into GanttChart and TaskRow so non-dragged chain members visually move during drag. Add onCascade prop to GanttChart. Update demo page with cascade example.

Purpose: Without this wiring, getSuccessorChain computes the chain but no TaskRow re-renders during drag to show the cascade. This plan makes it visible: GanttChart holds a cascadeOverrides Map, passes overridePosition to each TaskRow, and TaskRow uses it when set.

Output:
- GanttChart: `cascadeOverrides` state, `handleCascadeProgress` callback, `onCascade` prop, updated TaskRow render
- TaskRow: `overridePosition` prop, updated `arePropsEqual`, updated render logic
- page.tsx: Updated demo with FS dependency chain showcasing real-time cascade + onCascade handler
</objective>

<execution_context>
@C:/Users/Volobuev/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Volobuev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-dependencies-constraits/07-CONTEXT.md
@.planning/phases/07-dependencies-constraits/07-RESEARCH.md
@.planning/phases/07-dependencies-constraits/07-01-SUMMARY.md
@packages/gantt-lib/src/components/GanttChart/GanttChart.tsx
@packages/gantt-lib/src/components/TaskRow/TaskRow.tsx
@packages/website/src/app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add overridePosition to TaskRow</name>
  <files>packages/gantt-lib/src/components/TaskRow/TaskRow.tsx</files>
  <action>
Make three changes to `packages/gantt-lib/src/components/TaskRow/TaskRow.tsx`:

**1. Extend `TaskRowProps` interface** — add `overridePosition` after `disableConstraints`:
```typescript
  /** Position override for cascade preview — when set, overrides both static and drag position */
  overridePosition?: { left: number; width: number };
```

Also extend with the new callback props from Plan 01:
```typescript
  /** Called each RAF during cascade drag with override positions for non-dragged chain tasks */
  onCascadeProgress?: (overrides: Map<string, { left: number; width: number }>) => void;
  /** Called when cascade drag completes; receives all shifted tasks including dragged task */
  onCascade?: (tasks: Task[]) => void;
```

**2. Update `arePropsEqual`** — add `overridePosition` comparison before the closing parenthesis:
```typescript
    prevProps.overridePosition?.left === nextProps.overridePosition?.left &&
    prevProps.overridePosition?.width === nextProps.overridePosition?.width
```
This is critical: without this, chain tasks won't re-render during drag even though GanttChart updated `cascadeOverrides`. See RESEARCH.md Pitfall 3.

**3. Update the component function signature** to destructure `overridePosition`, `onCascadeProgress`, `onCascade`:
In the `React.memo(({ ... }) => {` destructuring, add:
```typescript
overridePosition, onCascadeProgress, onCascade
```

**4. Pass new options to `useTaskDrag`** — in the `useTaskDrag({ ... })` call, add:
```typescript
      onCascadeProgress,
      onCascade,
```

**5. Update render position logic** — replace:
```typescript
    const displayLeft = isDragging ? currentLeft : left;
    const displayWidth = isDragging ? currentWidth : width;
```
With:
```typescript
    const displayLeft = overridePosition?.left ?? (isDragging ? currentLeft : left);
    const displayWidth = overridePosition?.width ?? (isDragging ? currentWidth : width);
```
The override takes priority over both drag state and static position. When a task is not the dragged one but is in the cascade chain, GanttChart drives its preview position.

**6. Update `handleDragEnd`** — the onDragEnd result now optionally carries `updatedDependencies` (from Plan 01). Update `handleDragEnd` to spread them:
```typescript
    const handleDragEnd = (result: { id: string; startDate: Date; endDate: Date; updatedDependencies?: Task['dependencies'] }) => {
      const updatedTask: Task = {
        ...task,
        startDate: result.startDate.toISOString(),
        endDate: result.endDate.toISOString(),
        ...(result.updatedDependencies !== undefined && { dependencies: result.updatedDependencies }),
      };
      onChange?.(updatedTask);
    };
```

No other changes. The `arePropsEqual` must NOT include `onCascadeProgress` or `onCascade` (same pattern as `onChange` — callbacks excluded from comparison because GanttChart wraps them in `useCallback`).
  </action>
  <verify>
Run `npm run build` from `packages/gantt-lib` — TypeScript must compile with zero errors.
  </verify>
  <done>
TaskRow has `overridePosition` in props and `arePropsEqual`. Render uses `overridePosition?.left ?? ...`. `handleDragEnd` spreads `updatedDependencies`. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cascade state and onCascade prop to GanttChart, update demo page</name>
  <files>
    packages/gantt-lib/src/components/GanttChart/GanttChart.tsx
    packages/website/src/app/page.tsx
  </files>
  <action>
**GanttChart.tsx changes:**

**1. Add `onCascade` prop to `GanttChartProps`**:
```typescript
  /** Called when a cascade drag completes; receives all shifted tasks (including dragged task) in hard mode */
  onCascade?: (tasks: Task[]) => void;
```

**2. Add `cascadeOverrides` state** inside `GanttChart` component body (after `validationResult` state):
```typescript
  const [cascadeOverrides, setCascadeOverrides] = useState<Map<string, { left: number; width: number }>>(new Map());
```

**3. Add `handleCascadeProgress` callback** (after `handleDragStateChange`):
```typescript
  const handleCascadeProgress = useCallback((overrides: Map<string, { left: number; width: number }>) => {
    setCascadeOverrides(new Map(overrides)); // new Map() forces re-render
  }, []);
```

**4. Destructure `onCascade` in component function** arguments.

**5. Update `tasks.map(...)` render** — pass `overridePosition`, `onCascadeProgress`, `onCascade` to each TaskRow:
```tsx
          {tasks.map((task, index) => (
            <TaskRow
              key={task.id}
              task={task}
              monthStart={monthStart}
              dayWidth={dayWidth}
              rowHeight={rowHeight}
              onChange={handleTaskChange}
              onDragStateChange={handleDragStateChange}
              rowIndex={index}
              allTasks={tasks}
              enableAutoSchedule={enableAutoSchedule ?? false}
              disableConstraints={disableConstraints ?? false}
              overridePosition={cascadeOverrides.get(task.id)}
              onCascadeProgress={handleCascadeProgress}
              onCascade={handleCascade}
            />
          ))}
```

**6. Add `handleCascade` callback** that calls `onCascade` (the external prop) AND updates GanttChart tasks state via `onChange`. Cascade means multiple tasks changed — use `onChange` with a functional updater that merges shifted tasks:
```typescript
  const handleCascade = useCallback((cascadedTasks: Task[]) => {
    // Update state by merging cascaded tasks
    onChange?.((currentTasks) => {
      const cascadeMap = new Map(cascadedTasks.map(t => [t.id, t]));
      return currentTasks.map(t => cascadeMap.get(t.id) ?? t);
    });
    // Notify external consumer
    onCascade?.(cascadedTasks);
  }, [onChange, onCascade]);
```

**page.tsx changes:**

Read the current `packages/website/src/app/page.tsx` before modifying. Add/update the dependency chart section to demonstrate cascade behavior:

1. Find the existing dependency tasks state (set up in Phase 6 or quick-12). If there is already a `dependencyTasks` state, update it to include a clear FS chain for cascade demonstration. Add or replace with:

```typescript
  // Cascade demo: A→B→C chain for Phase 7 cascade demonstration
  const [cascadeTasks, setCascadeTasks] = useState([
    {
      id: 'cascade-a',
      name: 'Задача A (перетащи меня)',
      startDate: '2026-02-01',
      endDate: '2026-02-05',
      color: '#3b82f6',
    },
    {
      id: 'cascade-b',
      name: 'Задача B (FS+0)',
      startDate: '2026-02-06',
      endDate: '2026-02-10',
      color: '#10b981',
      dependencies: [{ taskId: 'cascade-a', type: 'FS' as const, lag: 0 }],
    },
    {
      id: 'cascade-c',
      name: 'Задача C (FS+0)',
      startDate: '2026-02-11',
      endDate: '2026-02-15',
      color: '#f59e0b',
      dependencies: [{ taskId: 'cascade-b', type: 'FS' as const, lag: 0 }],
    },
    {
      id: 'cascade-d',
      name: 'Задача D (независимая)',
      startDate: '2026-02-08',
      endDate: '2026-02-12',
      color: '#8b5cf6',
    },
  ]);
```

2. Add a new section to the JSX (or update the existing dependency section) that uses `cascadeTasks` with `onCascade`:
```tsx
          <div className={styles.section}>
            <h2 className={styles.sectionTitle}>Каскадное смещение (Phase 7)</h2>
            <p className={styles.sectionDescription}>
              Жёсткий режим: перетащи «Задача A» — B и C двигаются вместе.
              D — независимая, не смещается.
            </p>
            <GanttChart
              tasks={cascadeTasks}
              onChange={setCascadeTasks}
              onCascade={(shifted) => setCascadeTasks(prev => {
                const m = new Map(shifted.map(t => [t.id, t]));
                return prev.map(t => m.get(t.id) ?? t);
              })}
              dayWidth={40}
              rowHeight={40}
            />
          </div>
```

Note: If `handleCascade` in GanttChart already calls `onChange` (which sets state), then the `onCascade` prop in the demo can just be used for logging, since the state update is handled internally. But to show the pattern, log it:
```tsx
              onCascade={(shifted) => console.log('Cascade complete:', shifted.map(t => t.name))}
```
And `setCascadeTasks` is passed as `onChange` — GanttChart's `handleCascade` will update state via `onChange` with a functional updater.

Final demo usage:
```tsx
            <GanttChart
              tasks={cascadeTasks}
              onChange={setCascadeTasks}
              onCascade={(shifted) => console.log('Cascade:', shifted.map(t => `${t.name}: ${t.startDate}`))}
              dayWidth={40}
              rowHeight={40}
            />
```

Keep all existing sections on the demo page. Add the cascade section as new content.
  </action>
  <verify>
1. Run `npm run build` from project root — full monorepo build must succeed (gantt-lib + website).
2. Run `npm test` from `packages/gantt-lib` — all tests pass.
3. Run `npm run dev` in `packages/website`, visit http://localhost:3000:
   - Scroll to cascade section
   - Drag "Задача A" right — B and C should visually follow in real time
   - Release — B and C have updated dates, D is unchanged
   - Open browser console — "Cascade:" log shows task names and new dates
  </verify>
  <done>
GanttChart has `cascadeOverrides` state and `handleCascadeProgress`. TaskRow receives `overridePosition`. Demo page shows real-time cascade. Full monorepo build passes. All tests pass.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify cascade drag behavior end-to-end</name>
  <what-built>
Full Phase 7 cascade system:
- Hard mode: predecessor drag cascades all FS successors in real time; child-left drag stops at predecessor.startDate
- Soft mode: task moves freely, lag recalculates on complete
- onCascade callback delivers all shifted tasks
- Demo page shows cascade section with A→B→C chain
  </what-built>
  <how-to-verify>
1. Run `npm run build` from project root — must succeed
2. Run `npm run dev` from `packages/website`
3. Visit http://localhost:3000
4. Scroll to "Каскадное смещение (Phase 7)" section

**Test hard mode cascade (predecessor drag):**
- Drag "Задача A" 5 days to the right
- During drag: B and C bars should move together with A in real time (no delay)
- Release: B and C dates updated, D stays in place
- Check console: "Cascade:" log with 3 tasks (A, B, C)

**Test hard mode cascade (child drag right):**
- Drag "Задача B" 3 days to the right
- B and C should move together (B is a predecessor of C)
- A stays in place (predecessor not affected)

**Test hard mode left boundary:**
- Drag "Задача B" to the left
- B should stop moving when its left edge reaches where A starts (not where A ends)
- Task freezes silently with no visual indicator

**Test that D is unaffected:**
- D has no dependencies, dragging any other task should never move D

5. Check that existing constraints still work (if there was a constraint demo from Phase 6, it should still function)
6. Run `npm run build` — confirm clean build after verification
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` from project root succeeds (zero TypeScript errors, zero warnings)
2. `npm test` from `packages/gantt-lib` — all tests pass
3. Real-time cascade preview works during drag (all chain tasks move together)
4. Cascade completes with correct dates for all chain members
5. D (independent task) is never affected by cascade drag
6. Hard-mode left boundary stops at predecessor.startDate
7. onCascade receives all shifted tasks including dragged task
8. Soft mode (if disableConstraints=true): task moves freely, lag updates in state after release
</verification>

<success_criteria>
1. Drag predecessor → all FS successors follow in real time (visual cascade)
2. Release → onCascade fires with all shifted tasks, state updates correctly
3. Drag child left → stops at predecessor.startDate pixel boundary (not endDate)
4. Independent tasks never shift during cascade drag
5. Browser console shows cascade log on completion
6. `npm run build` clean from project root
7. All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/07-dependencies-constraits/07-02-SUMMARY.md`
</output>
