---
phase: 07-dependencies-constraits
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/gantt-lib/src/utils/dependencyUtils.ts
  - packages/gantt-lib/src/hooks/useTaskDrag.ts
autonomous: true
requirements: [PHASE7-CORE]

must_haves:
  truths:
    - "getSuccessorChain() returns all FS successors of a dragged task (excludes the dragged task itself)"
    - "Hard mode: during drag, onCascadeProgress is called with pixel overrides for all chain members"
    - "Hard mode: child dragged left stops at predecessor.startDate (not endDate), task freezes silently"
    - "Soft mode: on drag complete, onChange is called with updatedTask where dependencies[] has recalculated lag values"
    - "globalActiveDrag carries cascadeChain and onCascadeProgress for real-time preview"
  artifacts:
    - path: "packages/gantt-lib/src/utils/dependencyUtils.ts"
      provides: "getSuccessorChain BFS traversal"
      contains: "getSuccessorChain"
    - path: "packages/gantt-lib/src/hooks/useTaskDrag.ts"
      provides: "Cascade delta emission and soft-mode lag recalculation"
      contains: "cascadeChain|onCascadeProgress|recalculateIncomingLags"
  key_links:
    - from: "useTaskDrag.ts handleGlobalMouseMove"
      to: "getSuccessorChain"
      via: "Called once on drag start, stored in globalActiveDrag.cascadeChain"
      pattern: "cascadeChain"
    - from: "useTaskDrag.ts handleGlobalMouseMove"
      to: "globalActiveDrag.onCascadeProgress"
      via: "Called each RAF with Map<taskId, {left, width}>"
      pattern: "onCascadeProgress"
    - from: "useTaskDrag.ts handleComplete"
      to: "recalculateIncomingLags"
      via: "Called in soft mode before onChange fires"
      pattern: "recalculateIncomingLags"
---

<objective>
Add the cascade chain engine: BFS successor traversal in dependencyUtils, and cascade delta emission + soft-mode lag recalculation in useTaskDrag.

Purpose: This is the algorithmic core of Phase 7. The cascade chain must be computed once on drag start, then used every RAF to emit position overrides for all non-dragged chain members. Soft mode must recalculate incoming lag on completion.

Output:
- `getSuccessorChain(draggedTaskId, allTasks): Task[]` in dependencyUtils.ts (FS-only BFS, excludes dragged task)
- Extended `ActiveDragState` with `cascadeChain: Task[]` and `onCascadeProgress?` callback
- `handleGlobalMouseMove` extended: hard-mode emits cascade overrides, hard-mode left boundary uses `predecessor.startDate`
- `handleComplete` extended: soft-mode calls `onChange` with recalculated `dependencies[]`
- `handleMouseDown` extended: computes cascadeChain on drag start
</objective>

<execution_context>
@C:/Users/Volobuev/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Volobuev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dependencies-constraits/07-CONTEXT.md
@.planning/phases/07-dependencies-constraits/07-RESEARCH.md
@packages/gantt-lib/src/utils/dependencyUtils.ts
@packages/gantt-lib/src/hooks/useTaskDrag.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getSuccessorChain to dependencyUtils.ts</name>
  <files>packages/gantt-lib/src/utils/dependencyUtils.ts</files>
  <action>
Add `getSuccessorChain` function at the end of `packages/gantt-lib/src/utils/dependencyUtils.ts`.

The function uses BFS from `draggedTaskId` through FS edges only, collecting all successors. The dragged task itself is seeded in `visited` but NOT added to `chain` — only its successors are returned. This prevents the "dragged task teleports" pitfall from RESEARCH.md.

```typescript
/**
 * Get all FS successor tasks of a dragged task using BFS (FS edges only, Phase 7).
 *
 * Returns tasks in breadth-first order (direct successors first, then their successors).
 * The dragged task itself is NOT included in the returned array.
 *
 * The visited set prevents infinite loops in case of cycles (cycle detection already
 * prevents cycles in valid data, but the guard adds safety during cascade computation).
 */
export function getSuccessorChain(
  draggedTaskId: string,
  allTasks: Task[]
): Task[] {
  // Build FS-only successor map: predecessor -> [successors]
  const successorMap = new Map<string, string[]>();
  for (const task of allTasks) {
    successorMap.set(task.id, []);
  }
  for (const task of allTasks) {
    if (!task.dependencies) continue;
    for (const dep of task.dependencies) {
      if (dep.type === 'FS') {
        const list = successorMap.get(dep.taskId) ?? [];
        list.push(task.id);
        successorMap.set(dep.taskId, list);
      }
    }
  }

  const taskById = new Map(allTasks.map(t => [t.id, t]));
  const visited = new Set<string>();
  const queue: string[] = [draggedTaskId];
  const chain: Task[] = [];
  visited.add(draggedTaskId); // seed — not added to chain

  while (queue.length > 0) {
    const current = queue.shift()!;
    const successors = successorMap.get(current) ?? [];
    for (const sid of successors) {
      if (!visited.has(sid)) {
        visited.add(sid);
        const t = taskById.get(sid);
        if (t) {
          chain.push(t);
          queue.push(sid);
        }
      }
    }
  }

  return chain; // excludes dragged task
}
```

No other changes to this file.
  </action>
  <verify>
Run `npm run build` from `packages/gantt-lib` — TypeScript must compile with zero errors.
Run `npm test` from `packages/gantt-lib` — all existing tests must still pass.
  </verify>
  <done>
`getSuccessorChain` is exported from dependencyUtils.ts, TypeScript compiles cleanly, all existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend useTaskDrag with cascade engine</name>
  <files>packages/gantt-lib/src/hooks/useTaskDrag.ts</files>
  <action>
Modify `packages/gantt-lib/src/hooks/useTaskDrag.ts` to implement the Phase 7 cascade engine. Make the following changes in order:

**1. Add import for getSuccessorChain** (top of file, alongside existing imports):
```typescript
import { calculateSuccessorDate, getSuccessorChain } from '../utils/dependencyUtils';
```

**2. Extend `ActiveDragState` interface** — add two fields after `disableConstraints`:
```typescript
  cascadeChain: Task[];        // FS successors of dragged task (Phase 7)
  onCascadeProgress?: (overrides: Map<string, { left: number; width: number }>) => void;
```

**3. Add `recalculateIncomingLags` helper function** — place it after `canMoveTask` function:
```typescript
/**
 * Recalculate lag for all FS dependencies linking predecessor(s) to this task.
 * Used in soft mode (disableConstraints=true) to update lag on drag complete.
 * Returns updated TaskDependency array with new lag values.
 */
function recalculateIncomingLags(
  task: Task,
  newStartDate: Date,
  allTasks: Task[]
): NonNullable<Task['dependencies']> {
  if (!task.dependencies) return [];
  const taskById = new Map(allTasks.map(t => [t.id, t]));

  return task.dependencies.map(dep => {
    if (dep.type !== 'FS') return dep; // Only recalc FS in Phase 7
    const predecessor = taskById.get(dep.taskId);
    if (!predecessor) return dep;
    const predEnd = new Date(predecessor.endDate instanceof Date ? predecessor.endDate : predecessor.endDate + (String(predecessor.endDate).includes('T') ? '' : 'T00:00:00Z'));
    // UTC-safe day difference: newStartDate - predecessor.endDate
    const lagMs = Date.UTC(
      newStartDate.getUTCFullYear(),
      newStartDate.getUTCMonth(),
      newStartDate.getUTCDate()
    ) - Date.UTC(
      predEnd.getUTCFullYear(),
      predEnd.getUTCMonth(),
      predEnd.getUTCDate()
    );
    const lagDays = Math.round(lagMs / (24 * 60 * 60 * 1000));
    return { ...dep, lag: lagDays };
  });
}
```

Note: predecessor dates come from `allTasks` which stores them as ISO strings (e.g. "2026-02-01T00:00:00.000Z"). Use `new Date(predecessor.endDate as string)` for simpler parsing since they are always stored as ISO strings after drag completion.

Simplify the helper body to:
```typescript
function recalculateIncomingLags(
  task: Task,
  newStartDate: Date,
  allTasks: Task[]
): NonNullable<Task['dependencies']> {
  if (!task.dependencies) return [];
  const taskById = new Map(allTasks.map(t => [t.id, t]));

  return task.dependencies.map(dep => {
    if (dep.type !== 'FS') return dep;
    const predecessor = taskById.get(dep.taskId);
    if (!predecessor) return dep;
    const predEnd = new Date(predecessor.endDate as string);
    const lagMs = Date.UTC(
      newStartDate.getUTCFullYear(),
      newStartDate.getUTCMonth(),
      newStartDate.getUTCDate()
    ) - Date.UTC(
      predEnd.getUTCFullYear(),
      predEnd.getUTCMonth(),
      predEnd.getUTCDate()
    );
    const lagDays = Math.round(lagMs / (24 * 60 * 60 * 1000));
    return { ...dep, lag: lagDays };
  });
}
```

**4. Extend `UseTaskDragOptions` interface** — add two fields after `disableConstraints`:
```typescript
  /** Callback for real-time cascade preview — called each RAF with non-dragged chain member positions */
  onCascadeProgress?: (overrides: Map<string, { left: number; width: number }>) => void;
  /** Callback when cascade completes — receives all shifted tasks including dragged task */
  onCascade?: (tasks: Task[]) => void;
```

**5. Extend `handleGlobalMouseMove`** — after the existing constraint block (the `if (mode === 'move' && allTasks.length > 0 && !globalActiveDrag.disableConstraints)` block), add cascade preview emission for hard mode:

Replace the existing hard-mode constraint block logic to also:
a) Use `predecessor.startDate` as the left boundary (not `predecessor.endDate` as the constraint anchor) — the existing `canMoveTask` uses `calculateSuccessorDate` which for FS returns `predecessor.endDate + lag`. That is correct for blocking the move. But the *clamp* boundary uses `calculateSuccessorDate` which already implements the right date. No change needed to the clamp logic — the clamp already correctly uses the dep's expected date.

Actually re-read: the CONTEXT.md says the hard-mode left boundary is `predecessor.startDate` meaning the child can go left until it reaches where the predecessor *starts* (allowing negative lag between predEnd and childStart). The current `canMoveTask` uses `calculateSuccessorDate(predStart, predEnd, dep.type, dep.lag)` for FS which returns `predEnd + lag`. For a task with lag=0, this means the child can't go before `predEnd`. This is the WRONG boundary per Phase 7 spec.

Per CONTEXT.md: "Двигаем последователя влево → упирается в `startDate` родителя". So the hard-mode left boundary for a child should be `predecessor.startDate`, not `predecessor.endDate + lag`.

Replace the existing hard-mode constraint check in `handleGlobalMouseMove` with a new one for Phase 7 that clamps the child at `predecessor.startDate`:

```typescript
    // Hard mode: check left-move boundary against predecessor.startDate (Phase 7)
    // Child can move left until its startDate would go before predecessor.startDate
    if (mode === 'move' && allTasks.length > 0 && !globalActiveDrag.disableConstraints) {
      const currentTask = allTasks.find(t => t.id === globalActiveDrag?.taskId);
      if (currentTask && currentTask.dependencies && currentTask.dependencies.length > 0) {
        let minAllowedLeft = 0; // in pixels from monthStart
        for (const dep of currentTask.dependencies) {
          if (dep.type !== 'FS') continue; // Phase 7: FS only
          const predecessor = globalActiveDrag.allTasks.find(t => t.id === dep.taskId);
          if (!predecessor) continue;
          // Boundary: child.startDate >= predecessor.startDate (allows negative lag)
          const predStart = new Date(predecessor.startDate as string);
          const predStartOffset = Math.round(
            (Date.UTC(predStart.getUTCFullYear(), predStart.getUTCMonth(), predStart.getUTCDate()) -
              Date.UTC(
                globalActiveDrag.monthStart.getUTCFullYear(),
                globalActiveDrag.monthStart.getUTCMonth(),
                globalActiveDrag.monthStart.getUTCDate()
              )) / (24 * 60 * 60 * 1000)
          );
          const predStartLeft = Math.round(predStartOffset * globalActiveDrag.dayWidth);
          minAllowedLeft = Math.max(minAllowedLeft, predStartLeft);
        }
        // Clamp: don't let task go left of boundary
        newLeft = Math.max(minAllowedLeft, newLeft);
      }
    }
```

Then after this constraint block, add the hard-mode cascade preview emission:

```typescript
    // Hard mode cascade: emit position overrides for all FS successor chain members
    if (mode === 'move' && !globalActiveDrag.disableConstraints &&
        globalActiveDrag.cascadeChain.length > 0 && globalActiveDrag.onCascadeProgress) {
      const draggedInitialLeft = globalActiveDrag.initialLeft;
      const deltaDays = Math.round((newLeft - draggedInitialLeft) / globalActiveDrag.dayWidth);
      const overrides = new Map<string, { left: number; width: number }>();
      for (const chainTask of globalActiveDrag.cascadeChain) {
        const chainStart = new Date(chainTask.startDate as string);
        const chainEnd = new Date(chainTask.endDate as string);
        const chainStartOffset = Math.round(
          (Date.UTC(chainStart.getUTCFullYear(), chainStart.getUTCMonth(), chainStart.getUTCDate()) -
            Date.UTC(
              globalActiveDrag.monthStart.getUTCFullYear(),
              globalActiveDrag.monthStart.getUTCMonth(),
              globalActiveDrag.monthStart.getUTCDate()
            )) / (24 * 60 * 60 * 1000)
        );
        const chainDuration = Math.round(
          (Date.UTC(chainEnd.getUTCFullYear(), chainEnd.getUTCMonth(), chainEnd.getUTCDate()) -
            Date.UTC(chainStart.getUTCFullYear(), chainStart.getUTCMonth(), chainStart.getUTCDate())
          ) / (24 * 60 * 60 * 1000)
        );
        const chainLeft = Math.round((chainStartOffset + deltaDays) * globalActiveDrag.dayWidth);
        const chainWidth = Math.round((chainDuration + 1) * globalActiveDrag.dayWidth); // +1 inclusive
        overrides.set(chainTask.id, { left: chainLeft, width: chainWidth });
      }
      globalActiveDrag.onCascadeProgress(overrides);
    }
```

**6. Extend `handleMouseDown`** — in `useTaskDrag` function body, destructure new options:
```typescript
    onCascadeProgress,
    onCascade,
```
And when building `globalActiveDrag`, add:
```typescript
      cascadeChain: mode === 'move' && !disableConstraints
        ? getSuccessorChain(taskId, allTasks)
        : [],
      onCascadeProgress,
```

**7. Extend `handleComplete`** — the callback that fires on mouseup. Modify to:
a) Clear cascade overrides before calling onChange/onCascade: call `globalActiveDrag.onCascadeProgress?.(new Map())` BEFORE `globalActiveDrag = null` in `completeDrag()`. Wait — `completeDrag()` is a module-level function; `onCascadeProgress` is inside `globalActiveDrag`. Modify `completeDrag`:

```typescript
function completeDrag() {
  if (globalRafId !== null) {
    cancelAnimationFrame(globalRafId);
    globalRafId = null;
  }

  if (globalActiveDrag) {
    // Clear cascade overrides before completing (avoids stale preview positions)
    globalActiveDrag.onCascadeProgress?.(new Map());
    const { onComplete, currentLeft, currentWidth } = globalActiveDrag;
    globalActiveDrag = null;
    onComplete(currentLeft, currentWidth);
  }
}
```

b) In `handleComplete` callback (inside `useTaskDrag`), after computing `newStartDate`/`newEndDate`, handle two cases:
- **Hard mode + cascade chain**: build cascaded tasks array, call `onCascade(tasks[])` instead of `onDragEnd`. The `onCascade` and `onDragEnd` references must be threaded through the closure.
- **Soft mode**: call `onDragEnd` with updated task (dependencies[] recalculated).

Add `onCascadeProgress` and `onCascade` to the `UseTaskDragOptions` destructuring in `useTaskDrag` function body.

The `handleComplete` callback currently only calls `onDragEnd`. Extend it:

```typescript
  const handleComplete = useCallback((finalLeft: number, finalWidth: number) => {
    const wasOwner = isOwnerRef.current;
    isOwnerRef.current = false;

    const dayOffset = Math.round(finalLeft / dayWidth);
    const durationDays = Math.round(finalWidth / dayWidth) - 1;

    const newStartDate = new Date(Date.UTC(
      monthStart.getUTCFullYear(),
      monthStart.getUTCMonth(),
      monthStart.getUTCDate() + dayOffset
    ));

    const newEndDate = new Date(Date.UTC(
      monthStart.getUTCFullYear(),
      monthStart.getUTCMonth(),
      monthStart.getUTCDate() + dayOffset + durationDays
    ));

    setIsDragging(false);
    setDragMode(null);

    if (onDragStateChange) {
      onDragStateChange({ isDragging: false, dragMode: null, left: finalLeft, width: finalWidth });
    }

    if (wasOwner && onDragEnd) {
      // Determine what happened based on disableConstraints flag and allTasks
      const isSoftMode = disableConstraints;
      const cascadeChainRef = globalActiveDrag === null ? [] : []; // already cleared

      if (!isSoftMode && onCascade && allTasks.length > 0) {
        // Hard mode with onCascade: build cascaded tasks
        // Re-compute successor chain from current allTasks (globalActiveDrag already null, use allTasks closure)
        const chain = getSuccessorChain(taskId, allTasks);
        const deltaDays = dayOffset - Math.round(
          (Date.UTC(
            initialStartDate.getUTCFullYear(),
            initialStartDate.getUTCMonth(),
            initialStartDate.getUTCDate()
          ) - Date.UTC(
            monthStart.getUTCFullYear(),
            monthStart.getUTCMonth(),
            monthStart.getUTCDate()
          )) / (24 * 60 * 60 * 1000)
        );

        const cascadedTasks: Task[] = [
          { ...allTasks.find(t => t.id === taskId)!, startDate: newStartDate.toISOString(), endDate: newEndDate.toISOString() },
          ...chain.map(chainTask => {
            const origStart = new Date(chainTask.startDate as string);
            const origEnd = new Date(chainTask.endDate as string);
            const newStart = new Date(Date.UTC(
              origStart.getUTCFullYear(), origStart.getUTCMonth(), origStart.getUTCDate() + deltaDays
            ));
            const newEnd = new Date(Date.UTC(
              origEnd.getUTCFullYear(), origEnd.getUTCMonth(), origEnd.getUTCDate() + deltaDays
            ));
            return { ...chainTask, startDate: newStart.toISOString(), endDate: newEnd.toISOString() };
          }),
        ];
        onCascade(cascadedTasks);
      } else {
        // Soft mode OR hard mode without cascade (no FS successors): call onDragEnd
        if (isSoftMode && allTasks.length > 0) {
          // Recalculate lag for FS dependencies
          const currentTaskData = allTasks.find(t => t.id === taskId);
          if (currentTaskData) {
            const updatedDeps = recalculateIncomingLags(currentTaskData, newStartDate, allTasks);
            onDragEnd({ id: taskId, startDate: newStartDate, endDate: newEndDate });
            // Note: lag update is delivered by calling onChange with updatedTask including updated deps
            // GanttChart's handleTaskChange will merge. Here we pass updatedDeps via a separate mechanism.
            // SIMPLIFICATION: pass updated task via onDragEnd — GanttChart will call onChange.
            // The lag update requires onDragEnd to carry the full task. Since onDragEnd signature is fixed,
            // call onChange directly via a closure if available. Since we don't have direct onChange access,
            // the cleanest approach is: call onDragEnd normally. GanttChart will update the task's dates.
            // Lag recalc in soft mode is a Claude's Discretion item — deliver via a separate onSoftComplete callback,
            // OR embed updated deps in the onDragEnd result by extending the result type.
            // Decision: extend onDragEnd result to include optional updatedDependencies:
            // Actually, to minimize API surface changes, call onChange from TaskRow's handleDragEnd
            // by passing updatedDeps through. The cleanest minimal change:
            // Pass recalculated deps in the result object. But onDragEnd type is fixed in UseTaskDragOptions.
            // Simplest: add optional `updatedDependencies` to the result. Update UseTaskDragReturn handleComplete.
          }
        }
        onDragEnd({ id: taskId, startDate: newStartDate, endDate: newEndDate });
      }
    }
  }, [dayWidth, monthStart, onDragEnd, onDragStateChange, taskId, disableConstraints, onCascade, allTasks, initialStartDate]);
```

This is getting complex due to the lag recalculation needing to pass through to the task update. Use this cleaner approach:

**Revised approach for soft-mode lag delivery:**
- Extend the `onDragEnd` result to carry optional `updatedDependencies?: TaskDependency[]`
- In `handleComplete`, when soft mode, compute and include them
- In `TaskRow.handleDragEnd`, if `result.updatedDependencies` exists, spread them into `updatedTask`

Here is the complete revised `handleComplete` and the `UseTaskDragOptions.onDragEnd` signature change:

In `UseTaskDragOptions`:
```typescript
  onDragEnd?: (result: { id: string; startDate: Date; endDate: Date; updatedDependencies?: Task['dependencies'] }) => void;
```

In `handleComplete` inside `useTaskDrag`:
```typescript
  const handleComplete = useCallback((finalLeft: number, finalWidth: number) => {
    const wasOwner = isOwnerRef.current;
    isOwnerRef.current = false;

    const dayOffset = Math.round(finalLeft / dayWidth);
    const durationDays = Math.round(finalWidth / dayWidth) - 1;

    const newStartDate = new Date(Date.UTC(
      monthStart.getUTCFullYear(),
      monthStart.getUTCMonth(),
      monthStart.getUTCDate() + dayOffset
    ));
    const newEndDate = new Date(Date.UTC(
      monthStart.getUTCFullYear(),
      monthStart.getUTCMonth(),
      monthStart.getUTCDate() + dayOffset + durationDays
    ));

    setIsDragging(false);
    setDragMode(null);

    if (onDragStateChange) {
      onDragStateChange({ isDragging: false, dragMode: null, left: finalLeft, width: finalWidth });
    }

    if (wasOwner) {
      if (!disableConstraints && onCascade && allTasks.length > 0) {
        // Hard mode with onCascade: compute cascade and call onCascade
        const chain = getSuccessorChain(taskId, allTasks);
        if (chain.length > 0) {
          const origStartMs = Date.UTC(
            initialStartDate.getUTCFullYear(),
            initialStartDate.getUTCMonth(),
            initialStartDate.getUTCDate()
          );
          const newStartMs = Date.UTC(
            newStartDate.getUTCFullYear(),
            newStartDate.getUTCMonth(),
            newStartDate.getUTCDate()
          );
          const deltaDays = Math.round((newStartMs - origStartMs) / (24 * 60 * 60 * 1000));

          const draggedTaskData = allTasks.find(t => t.id === taskId);
          const cascadedTasks: Task[] = [
            { ...(draggedTaskData ?? { id: taskId, name: '', startDate: '', endDate: '' }), startDate: newStartDate.toISOString(), endDate: newEndDate.toISOString() },
            ...chain.map(chainTask => {
              const origStart = new Date(chainTask.startDate as string);
              const origEnd = new Date(chainTask.endDate as string);
              const newStart = new Date(Date.UTC(
                origStart.getUTCFullYear(), origStart.getUTCMonth(), origStart.getUTCDate() + deltaDays
              ));
              const newEnd = new Date(Date.UTC(
                origEnd.getUTCFullYear(), origEnd.getUTCMonth(), origEnd.getUTCDate() + deltaDays
              ));
              return { ...chainTask, startDate: newStart.toISOString(), endDate: newEnd.toISOString() };
            }),
          ];
          onCascade(cascadedTasks);
          return; // Don't call onDragEnd — cascade covers the dragged task too
        }
      }

      // Soft mode OR hard mode with no FS successors: call onDragEnd
      if (disableConstraints && allTasks.length > 0 && onDragEnd) {
        // Soft mode: recalculate lag
        const currentTaskData = allTasks.find(t => t.id === taskId);
        const updatedDependencies = currentTaskData
          ? recalculateIncomingLags(currentTaskData, newStartDate, allTasks)
          : undefined;
        onDragEnd({ id: taskId, startDate: newStartDate, endDate: newEndDate, updatedDependencies });
      } else if (onDragEnd) {
        onDragEnd({ id: taskId, startDate: newStartDate, endDate: newEndDate });
      }
    }
  }, [dayWidth, monthStart, onDragEnd, onDragStateChange, taskId, disableConstraints, onCascade, allTasks, initialStartDate]);
```

Add `initialStartDate` to `handleComplete` deps (it's already in `UseTaskDragOptions` as `initialStartDate`). The `useTaskDrag` function already has `initialStartDate` in scope.

**8. Extend `handleMouseDown`** to destructure `onCascadeProgress` and `onCascade` from options and store in globalActiveDrag:

In the `useTaskDrag` function body, add to the options destructuring:
```typescript
    onCascadeProgress,
    onCascade,
```

In `globalActiveDrag = { ... }` inside `handleMouseDown`, add:
```typescript
      cascadeChain: mode === 'move' && !disableConstraints
        ? getSuccessorChain(taskId, allTasks)
        : [],
      onCascadeProgress,
```

Update `handleMouseDown`'s `useCallback` deps array to include `onCascadeProgress` and `onCascade`.

**Summary of all changes to useTaskDrag.ts:**
1. Import `getSuccessorChain` alongside `calculateSuccessorDate`
2. Add `cascadeChain: Task[]` and `onCascadeProgress?` to `ActiveDragState`
3. Add `recalculateIncomingLags` helper function
4. Replace existing hard-mode constraint block with Phase 7 `predecessor.startDate` boundary
5. Add cascade preview emission block after constraint block
6. Add `onCascadeProgress` and `onCascade` to `UseTaskDragOptions`
7. Update `onDragEnd` signature to include optional `updatedDependencies`
8. Extend `handleComplete` for cascade/soft-mode dispatch
9. Clear cascade overrides in `completeDrag()` before calling `onComplete`
10. Add `cascadeChain` + `onCascadeProgress` to `globalActiveDrag` in `handleMouseDown`
  </action>
  <verify>
Run `npm run build` from `packages/gantt-lib` — must compile with zero TypeScript errors.
Run `npm test` from `packages/gantt-lib` — all existing tests must pass.
  </verify>
  <done>
useTaskDrag.ts exports all cascade engine changes. TypeScript compiles. All existing tests pass. getSuccessorChain is imported and used in handleMouseDown and handleComplete.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run build` in `packages/gantt-lib` succeeds with no TypeScript errors
2. `npm test` in `packages/gantt-lib` — all existing tests pass
3. `getSuccessorChain` is exported from `dependencyUtils.ts`
4. `ActiveDragState` has `cascadeChain` and `onCascadeProgress` fields
5. `UseTaskDragOptions` has `onCascadeProgress` and `onCascade` fields
6. `onDragEnd` result type has optional `updatedDependencies`
7. `completeDrag()` clears cascade overrides before calling `onComplete`
</verification>

<success_criteria>
- `getSuccessorChain('A', tasks)` where A→B→C returns [B, C] (not A)
- `completeDrag()` calls `onCascadeProgress(new Map())` before `onComplete`
- Hard mode: `handleGlobalMouseMove` emits `onCascadeProgress` with pixel overrides for chain members
- Hard mode: left boundary clamps at `predecessor.startDate` pixel offset
- Soft mode: `handleComplete` calls `onDragEnd` with `updatedDependencies` containing recalculated lag
- Hard mode with chain: `handleComplete` calls `onCascade(tasks[])` instead of `onDragEnd`
- All monorepo builds and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-dependencies-constraits/07-01-SUMMARY.md`
</output>
