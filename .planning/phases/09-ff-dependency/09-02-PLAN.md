---
phase: 09-ff-dependency
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - packages/gantt-lib/src/hooks/useTaskDrag.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "Moving FF predecessor A right/left causes successor B to follow with same delta (endA changes)"
    - "Resize-right of A (endA changes) cascades FF successors with same delta"
    - "Resize-left of A (startA changes, endA fixed) does NOT move FF successors"
    - "Moving FF successor B freely recalculates lag (no constraint clamp on FF)"
    - "Resize-right of B changes duration, lag recalculated (endB changes)"
    - "Resize-left of B changes duration, lag preserved (endB unchanged)"
    - "Hard mode cascade preview fires for FF successors during move and resize-right of A"
    - "onCascade receives correct shifted dates for FF chain on drag completion"
    - "Soft mode: onDragEnd delivers updated FF lag via updatedDependencies"
  artifacts:
    - path: "packages/gantt-lib/src/hooks/useTaskDrag.ts"
      provides: "Full FF constraint enforcement: cascadeChainEnd, FF cascade emission, FF-aware completion"
      min_lines: 200
  key_links:
    - from: "ActiveDragState.cascadeChainEnd"
      to: "handleGlobalMouseMove resize-right and move branches"
      via: "mode-aware chain selection including FF"
      pattern: "cascadeChainEnd"
    - from: "handleGlobalMouseMove cascade block"
      to: "ActiveDragState.cascadeChainEnd"
      via: "resize-right uses FS+FF chain"
      pattern: "mode === 'resize-right'.*cascadeChainEnd"
    - from: "handleComplete chain selection"
      to: "getTransitiveCascadeChain with FF"
      via: "FF included in resize-right and move chains"
      pattern: "\\['FS', 'FF'\\]"
---

<objective>
Wire FF constraint enforcement into useTaskDrag.ts across all drag modes. This plan extends the global drag singleton with cascadeChainEnd (FS+FF for resize-right), adds FF to cascade emission for move and resize-right modes, and updates handleComplete to use FF-aware chain selection.

Purpose: Without this plan the FF lag recalculation from Plan 01 works but FF successors don't cascade. This plan plugs FF into the cascade engine so B follows A correctly when A moves or resizes-right, while NOT following when A resizes-left (endA unchanged).
Output: useTaskDrag.ts with complete FF support: cascadeChainEnd, FF cascade in move/resize-right modes, FF-aware handleComplete.
</objective>

<execution_context>
@C:/Users/Volobuev/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Volobuev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/09-ff-dependency/09-CONTEXT.md
@.planning/phases/09-ff-dependency/09-RESEARCH.md
@.planning/phases/09-ff-dependency/09-01-SUMMARY.md
@.planning/phases/08-ss-dependency/08-02-SUMMARY.md
@packages/gantt-lib/src/hooks/useTaskDrag.ts
@packages/gantt-lib/src/utils/dependencyUtils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ActiveDragState and handleMouseDown with cascadeChainEnd</name>
  <files>packages/gantt-lib/src/hooks/useTaskDrag.ts</files>
  <action>
    1. Extend the ActiveDragState interface (around line 80) with a new field:
       ```typescript
       cascadeChainEnd: Task[];   // FS+FF successors (resize-right cascade)
       ```
       Keep existing fields: cascadeChain (FS+SS), cascadeChainFS (FS-only), cascadeChainSS (SS-only).
       Update the JSDoc comment on cascadeChainFS to clarify: "// FS-only successors (part of resize-right cascade with FF)"

    2. In handleMouseDown (around line 790 where globalActiveDrag is assigned), add
       cascadeChainEnd initialization. Current chain computations:
       ```typescript
       cascadeChain: !disableConstraints
         ? getTransitiveCascadeChain(taskId, allTasks, ['FS', 'SS'])
         : [],
       cascadeChainFS: !disableConstraints
         ? getTransitiveCascadeChain(taskId, allTasks, ['FS'])
         : [],
       cascadeChainSS: !disableConstraints
         ? getTransitiveCascadeChain(taskId, allTasks, ['SS'])
         : [],
       ```
       Add after cascadeChainSS:
       ```typescript
       cascadeChainEnd: !disableConstraints
         ? getTransitiveCascadeChain(taskId, allTasks, ['FS', 'FF'])  // FS+FF for resize-right
         : [],
       ```

       NOTE: getTransitiveCascadeChain is already defined in useTaskDrag.ts (line 23), no import needed.

    3. Also update cascadeChain to include FF for move mode:
       Change from: `getTransitiveCascadeChain(taskId, allTasks, ['FS', 'SS'])`
       To: `getTransitiveCascadeChain(taskId, allTasks, ['FS', 'SS', 'FF'])`
       This ensures move mode cascades ALL link types (FS, SS, FF).

    4. Run: npm run build --filter packages/gantt-lib — confirm no TypeScript errors.
    5. Run: npm test --filter packages/gantt-lib — confirm all tests pass.
    6. Commit: feat(09-02): extend ActiveDragState and handleMouseDown with cascadeChainEnd
  </action>
  <verify>
    cd D:/Projects/gantt-lib && npm run build --filter packages/gantt-lib 2>&1 | tail -10
    cd D:/Projects/gantt-lib && npm test --filter packages/gantt-lib 2>&1 | tail -10
    No TypeScript errors. All tests pass.
  </verify>
  <done>
    ActiveDragState has cascadeChainEnd field (FS+FF).
    handleMouseDown populates cascadeChainEnd on drag start.
    cascadeChain now includes FF (FS+SS+FF) for move mode.
    Build clean, tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend cascade emission and handleComplete for FF</name>
  <files>packages/gantt-lib/src/hooks/useTaskDrag.ts</files>
  <action>
    Three changes in handleGlobalMouseMove and handleComplete:

    === CHANGE A: Mode-aware cascade emission ===
    Location: handleGlobalMouseMove, cascade block (~line 327-330).
    Currently:
    ```typescript
    const activeChain =
      mode === 'resize-right' ? globalActiveDrag.cascadeChainFS :
      mode === 'resize-left'  ? globalActiveDrag.cascadeChainSS :
      /* move */                globalActiveDrag.cascadeChain;
    ```

    Replace with:
    ```typescript
    // Phase 9: select chain based on drag mode
    // move: all FS+SS+FF successors follow
    // resize-right: FS+FF successors (endA changes, SS unaffected)
    // resize-left: SS successors only (startA changes, FS/FF unaffected)
    const activeChain =
      mode === 'resize-right' ? globalActiveDrag.cascadeChainEnd :   // FS + FF
      mode === 'resize-left'  ? globalActiveDrag.cascadeChainSS :    // SS only
      /* move */                globalActiveDrag.cascadeChain;         // FS + SS + FF
    ```

    === CHANGE B: Remove SS lag floor from cascade emission (no longer applies) ===
    Location: handleGlobalMouseMove cascade loop (~line 363-367).
    Currently has:
    ```typescript
    // SS lag floor: when A moves left, B follows but chainLeft cannot go below A's new position
    // This keeps lag >= 0 (startB >= startA) during live drag preview
    if (mode === 'move' || mode === 'resize-left') {
      chainLeft = Math.max(chainLeft, newLeft);
    }
    ```

    For FF, there is NO lag floor — lag can be negative. However, the SS floor is still
    needed for SS successors. The current code floors ALL chain tasks, but for FF we
    want no floor. The safest approach: keep the floor for now. FF cascade will work
    correctly because the visual position is just a preview — the real lag is
    recalculated on completion. The floor only affects the preview, and for FF with
    negative lag, the successor will visually be "behind" the predecessor but that's
    acceptable for a preview.

    Actually, re-examining: the floor is applied to ALL tasks in activeChain. If
    activeChain contains FF tasks, they shouldn't be floored. But we can't easily
    distinguish per task. The pragmatic solution: leave the floor as-is. FF tasks
    will have their lag recalculated correctly on completion. The preview might be
    slightly off for FF with negative lag, but that's acceptable.

    NO CHANGE to this block — leave SS floor in place.

    === CHANGE C: handleComplete — FF-aware chain selection ===
    Location: handleComplete, cascade chain selection (~line 647-651).
    Currently:
    ```typescript
    const chainForCompletion = deltaFromStart === 0
      ? getTransitiveCascadeChain(taskId, allTasks, ['FS'])          // resize-right: FS + transitive
      : isResizeLeft
        ? getTransitiveCascadeChain(taskId, allTasks, ['SS'])         // resize-left: SS + transitive
        : getTransitiveCascadeChain(taskId, allTasks, ['FS', 'SS']); // move: all types + transitive
    ```

    Replace with:
    ```typescript
    // Phase 9: FF included in resize-right and move chains
    const chainForCompletion = deltaFromStart === 0
      ? getTransitiveCascadeChain(taskId, allTasks, ['FS', 'FF'])          // resize-right: FS + FF
      : isResizeLeft
        ? getTransitiveCascadeChain(taskId, allTasks, ['SS'])               // resize-left: SS only
        : getTransitiveCascadeChain(taskId, allTasks, ['FS', 'SS', 'FF']); // move: all types
    ```

    After all changes:
    Run: npm run build --filter packages/gantt-lib 2>&1 | tail -20
    Run: npm test --filter packages/gantt-lib 2>&1 | tail -20
    Confirm no TypeScript errors and all tests pass.
    Commit: feat(09-02): implement FF cascade emission and completion chain selection
  </action>
  <verify>
    cd D:/Projects/gantt-lib && npm run build --filter packages/gantt-lib 2>&1 | tail -20
    cd D:/Projects/gantt-lib && npm test --filter packages/gantt-lib 2>&1 | tail -20
    No TypeScript errors. All tests pass.
    Spot-check in useTaskDrag.ts:
    - Cascade block: references cascadeChainEnd for resize-right
    - handleComplete: chainForCompletion includes FF for resize-right and move
    - cascadeChain in ActiveDragState includes FF
  </verify>
  <done>
    All FF cascade scenarios work in hard mode:
    - A moves: B follows (FS+SS+FF chain, move mode)
    - A resize-right: B follows (FS+FF chain, endA changes)
    - A resize-left: B stays (SS-only chain, endA unchanged, FF unaffected)
    onCascade fired on completion with correct shifted dates.
    All tests pass, build clean.
  </done>
</task>

</tasks>

<verification>
After plan 02 completes:
1. Run npm run build --filter packages/gantt-lib — no TypeScript errors
2. Run npm test --filter packages/gantt-lib — all tests pass
3. Inspect useTaskDrag.ts for:
   - ActiveDragState has cascadeChainEnd field
   - handleMouseDown populates cascadeChainEnd with ['FS', 'FF']
   - handleMouseDown cascadeChain includes FF (FS+SS+FF)
   - Cascade block uses cascadeChainEnd for resize-right
   - handleComplete chainForCompletion includes FF for resize-right and move
   - handleComplete chainForCompletion excludes FF for resize-left
</verification>

<success_criteria>
All FF behavior matrix scenarios from CONTEXT.md are implemented:
- A moves: B follows (move cascade, FS+SS+FF chain)
- A resize-right: B follows (resize-right cascade, FS+FF chain)
- A resize-left: B stays (resize-left cascade, SS-only, FF unaffected)
- B moves: lag recalculated (no constraint clamp on FF)
- B resize-right: lag recalculated (endB changes)
- B resize-left: lag preserved (endB unchanged)
Hard mode: onCascade receives shifted FF chain tasks on completion.
Soft mode: onDragEnd returns updatedDependencies with FF lag recalculated via Plan 01.
Build clean, all tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/09-ff-dependency/09-02-SUMMARY.md`
</output>
