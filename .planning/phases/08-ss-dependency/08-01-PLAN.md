---
phase: 08-ss-dependency
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/gantt-lib/src/utils/dependencyUtils.ts
  - packages/gantt-lib/src/__tests__/dependencyUtils.test.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "getSuccessorChain called with ['FS'] returns only FS successors (unchanged Phase 7 behavior)"
    - "getSuccessorChain called with ['SS'] returns only SS successors"
    - "getSuccessorChain called with ['FS', 'SS'] returns union of FS and SS successors"
    - "recalculateIncomingLags for SS dep returns lag = startB - startA, floored at 0"
    - "recalculateIncomingLags for FS dep is unchanged (no floor, uses endA)"
  artifacts:
    - path: "packages/gantt-lib/src/utils/dependencyUtils.ts"
      provides: "getSuccessorChain with linkTypes param; recalculateIncomingLags with SS case"
      exports: ["getSuccessorChain"]
    - path: "packages/gantt-lib/src/__tests__/dependencyUtils.test.ts"
      provides: "Tests for SS-extended getSuccessorChain and recalculateIncomingLags"
  key_links:
    - from: "packages/gantt-lib/src/hooks/useTaskDrag.ts"
      to: "packages/gantt-lib/src/utils/dependencyUtils.ts"
      via: "import { getSuccessorChain }"
      pattern: "getSuccessorChain\\(taskId, allTasks"
---

<objective>
Extend `getSuccessorChain` in dependencyUtils.ts to accept a `linkTypes` parameter so callers can request FS-only, SS-only, or FS+SS chains. Also extend `recalculateIncomingLags` (in useTaskDrag.ts) to handle SS deps with the correct formula and a lag-floor at 0.

Purpose: These are the foundational utility changes Phase 8 depends on. Plan 02 needs the new `getSuccessorChain` signature to populate mode-aware cascade chains on drag start.
Output: Updated dependencyUtils.ts with parameterized getSuccessorChain; updated useTaskDrag.ts recalculateIncomingLags; comprehensive tests for SS branches.
</objective>

<execution_context>
@C:/Users/Volobuev/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Volobuev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ss-dependency/08-CONTEXT.md
@.planning/phases/08-ss-dependency/08-RESEARCH.md
@packages/gantt-lib/src/utils/dependencyUtils.ts
@packages/gantt-lib/src/hooks/useTaskDrag.ts
@packages/gantt-lib/src/__tests__/dependencyUtils.test.ts
</context>

<feature>
  <name>getSuccessorChain — linkTypes parameter</name>
  <files>
    packages/gantt-lib/src/utils/dependencyUtils.ts
    packages/gantt-lib/src/__tests__/dependencyUtils.test.ts
  </files>
  <behavior>
    getSuccessorChain(draggedTaskId, allTasks, linkTypes?) BFS traversal.

    New signature:
      export function getSuccessorChain(
        draggedTaskId: string,
        allTasks: Task[],
        linkTypes: LinkType[] = ['FS']   // Phase 7 default preserved
      ): Task[]

    The successorMap build loop changes from:
      if (dep.type === 'FS')
    to:
      if (linkTypes.includes(dep.type))

    This is the ONLY structural change to getSuccessorChain. BFS loop, visited set,
    chain building — all unchanged.

    Test cases:
    - getSuccessorChain('A', tasks) with tasks=[A→(FS)→B] returns [B]  (default ['FS'])
    - getSuccessorChain('A', tasks, ['FS']) with tasks=[A→(FS)→B, A→(SS)→C] returns [B] only
    - getSuccessorChain('A', tasks, ['SS']) with tasks=[A→(FS)→B, A→(SS)→C] returns [C] only
    - getSuccessorChain('A', tasks, ['FS','SS']) with above returns [B, C] (order: BFS)
    - getSuccessorChain('A', tasks, ['SS']) with A→(SS)→B→(SS)→C returns [B, C] (deep chain)
    - Dragged task 'A' never appears in returned chain even when A→(SS)→A cycle data exists
  </behavior>
  <implementation>
    RED: Write all getSuccessorChain SS tests in a new describe('getSuccessorChain') block
    in dependencyUtils.test.ts — run vitest, confirm they fail.

    GREEN: Add linkTypes parameter to getSuccessorChain. Change the filter in the
    successorMap build loop: replace `dep.type === 'FS'` with `linkTypes.includes(dep.type)`.
    Default parameter = ['FS'] preserves backward compatibility — existing callers in
    useTaskDrag.ts (line 652 and line 498) keep working without change.

    Also add the LinkType import if not already present in dependencyUtils.ts.

    Run vitest — all tests pass.
  </implementation>
</feature>

<feature>
  <name>recalculateIncomingLags — SS case</name>
  <files>
    packages/gantt-lib/src/hooks/useTaskDrag.ts
    packages/gantt-lib/src/__tests__/dependencyUtils.test.ts
  </files>
  <behavior>
    recalculateIncomingLags(task, newStartDate, allTasks) currently handles only FS.
    Extend to also handle SS.

    SS formula: lag = newSuccessorStartDate - predecessorStartDate (in days), clamped >= 0.
    FS formula: lag = newSuccessorStartDate - predecessorEndDate (unchanged, no floor).

    Current code (useTaskDrag.ts lines 148-164):
      return task.dependencies.map(dep => {
        if (dep.type !== 'FS') return dep;
        const predecessor = taskById.get(dep.taskId);
        if (!predecessor) return dep;
        const predEnd = new Date(predecessor.endDate as string);
        const lagMs = Date.UTC(newStartDate...) - Date.UTC(predEnd...);
        const lagDays = Math.round(lagMs / (24 * 60 * 60 * 1000));
        return { ...dep, lag: lagDays };
      });

    New code structure:
      return task.dependencies.map(dep => {
        if (dep.type === 'FS') {
          // existing FS code using predecessor.endDate
        }
        if (dep.type === 'SS') {
          const predecessor = taskById.get(dep.taskId);
          if (!predecessor) return dep;
          const predStart = new Date(predecessor.startDate as string);
          const lagMs = Date.UTC(newStartDate.getUTCFullYear(), newStartDate.getUTCMonth(), newStartDate.getUTCDate())
                      - Date.UTC(predStart.getUTCFullYear(), predStart.getUTCMonth(), predStart.getUTCDate());
          const lagDays = Math.max(0, Math.round(lagMs / (24 * 60 * 60 * 1000)));  // SS: floor at 0
          return { ...dep, lag: lagDays };
        }
        return dep; // FF, SF: unchanged
      });

    Test cases (add to dependencyUtils.test.ts as describe('recalculateIncomingLags') or
    integrate into useTaskDrag unit tests if a test file exists — prefer dependencyUtils.test.ts
    by extracting the function or testing via integration):

    Since recalculateIncomingLags is a module-private function in useTaskDrag.ts, test it
    INDIRECTLY via the existing drag completion behavior observable from onDragEnd results.
    If no useTaskDrag.test.ts exists, skip the test for this private function and add a
    comment: "// Tested indirectly via handleComplete soft-mode path in integration tests".
    Add an explanatory comment in the code instead.
  </behavior>
  <implementation>
    RED: Add describe('recalculateIncomingLags - SS') in dependencyUtils.test.ts if
    the function is exported, or skip test file changes if private — note in code.

    GREEN: Modify the if-chain in recalculateIncomingLags in useTaskDrag.ts:
    - Change `if (dep.type !== 'FS') return dep;` to an if/if-else/return pattern
    - FS branch: existing logic (predEnd, no floor)
    - SS branch: predStart, Math.max(0, lagDays)
    - Default return dep for FF/SF

    Run vitest — confirm all existing tests still pass.
  </implementation>
</feature>

<tasks>

<task type="tdd">
  <name>Task 1: Extend getSuccessorChain with linkTypes parameter (RED → GREEN)</name>
  <files>
    packages/gantt-lib/src/utils/dependencyUtils.ts
    packages/gantt-lib/src/__tests__/dependencyUtils.test.ts
  </files>
  <action>
    RED phase:
    Add a new describe('getSuccessorChain') block to dependencyUtils.test.ts. Import getSuccessorChain from '../utils/dependencyUtils'. Write tests:
    1. "returns FS successors with default linkTypes": tasks A→(FS)→B, A→(SS)→C; call getSuccessorChain('A', tasks) (no 3rd arg) → expect [B]
    2. "returns only FS successors when linkTypes=['FS']": same tasks, explicit ['FS'] → expect [B]
    3. "returns only SS successors when linkTypes=['SS']": same tasks → expect [C]
    4. "returns FS+SS successors when linkTypes=['FS','SS']": same tasks → expect result.length === 2, contains both B and C
    5. "traverses deep SS chain": A→(SS)→B→(SS)→C, call with ['SS'] → expect [B, C]
    6. "excludes dragged task from result": A→(SS)→A (self-link, invalid but guarded) — verify 'A' not in result
    7. "returns empty array when no successors of given type": A→(FS)→B, call with ['SS'] → expect []
    Run: npm test --filter packages/gantt-lib → confirm these 7 tests FAIL (function doesn't accept linkTypes yet). Commit: test(08-01): add failing tests for getSuccessorChain SS extension

    GREEN phase:
    Modify getSuccessorChain in packages/gantt-lib/src/utils/dependencyUtils.ts:
    - Add `linkTypes: LinkType[] = ['FS']` as third parameter
    - Add LinkType to the import from '../types' if not already imported
    - Change the successorMap build loop filter: replace `if (dep.type === 'FS')` with `if (linkTypes.includes(dep.type))`
    - No other changes to the function body
    Run: npm test --filter packages/gantt-lib → confirm all tests pass. Commit: feat(08-01): extend getSuccessorChain with linkTypes parameter
  </action>
  <verify>
    cd D:/Projects/gantt-lib && npm test --filter packages/gantt-lib 2>&1 | grep -E "(PASS|FAIL|✓|✗|Tests)"
    All tests must pass. The 7 new getSuccessorChain tests must be among passing tests.
  </verify>
  <done>
    getSuccessorChain accepts optional linkTypes parameter (default ['FS'] for backward compat).
    All 7 new tests pass. All pre-existing tests pass. No TypeScript errors.
  </done>
</task>

<task type="tdd">
  <name>Task 2: Extend recalculateIncomingLags for SS dependency type (GREEN)</name>
  <files>
    packages/gantt-lib/src/hooks/useTaskDrag.ts
  </files>
  <action>
    recalculateIncomingLags is a module-private function in useTaskDrag.ts (not exported).
    No unit test for it exists separately. Skip writing a unit test file — add a comment
    in the function body noting SS behavior and the lag floor.

    Modify recalculateIncomingLags in packages/gantt-lib/src/hooks/useTaskDrag.ts (lines 140-165):

    Current:
      return task.dependencies.map(dep => {
        if (dep.type !== 'FS') return dep;
        const predecessor = taskById.get(dep.taskId);
        if (!predecessor) return dep;
        const predEnd = new Date(predecessor.endDate as string);
        const lagMs = Date.UTC(
          newStartDate.getUTCFullYear(),
          newStartDate.getUTCMonth(),
          newStartDate.getUTCDate()
        ) - Date.UTC(
          predEnd.getUTCFullYear(),
          predEnd.getUTCMonth(),
          predEnd.getUTCDate()
        );
        const lagDays = Math.round(lagMs / (24 * 60 * 60 * 1000));
        return { ...dep, lag: lagDays };
      });

    Replace with:
      return task.dependencies.map(dep => {
        if (dep.type === 'FS') {
          // FS: lag = newSuccessorStart - predecessorEnd (can be negative)
          const predecessor = taskById.get(dep.taskId);
          if (!predecessor) return dep;
          const predEnd = new Date(predecessor.endDate as string);
          const lagMs = Date.UTC(
            newStartDate.getUTCFullYear(),
            newStartDate.getUTCMonth(),
            newStartDate.getUTCDate()
          ) - Date.UTC(
            predEnd.getUTCFullYear(),
            predEnd.getUTCMonth(),
            predEnd.getUTCDate()
          );
          const lagDays = Math.round(lagMs / (24 * 60 * 60 * 1000));
          return { ...dep, lag: lagDays };
        }
        if (dep.type === 'SS') {
          // SS: lag = newSuccessorStart - predecessorStart (always >= 0 per SS semantics)
          const predecessor = taskById.get(dep.taskId);
          if (!predecessor) return dep;
          const predStart = new Date(predecessor.startDate as string);
          const lagMs = Date.UTC(
            newStartDate.getUTCFullYear(),
            newStartDate.getUTCMonth(),
            newStartDate.getUTCDate()
          ) - Date.UTC(
            predStart.getUTCFullYear(),
            predStart.getUTCMonth(),
            predStart.getUTCDate()
          );
          const lagDays = Math.max(0, Math.round(lagMs / (24 * 60 * 60 * 1000))); // SS lag >= 0
          return { ...dep, lag: lagDays };
        }
        return dep; // FF, SF: unchanged
      });

    Run: npm test --filter packages/gantt-lib → all pass. Run: npm run build --filter packages/gantt-lib → no TypeScript errors.
    Commit: feat(08-01): extend recalculateIncomingLags with SS lag formula
  </action>
  <verify>
    cd D:/Projects/gantt-lib && npm test --filter packages/gantt-lib 2>&1 | tail -20
    cd D:/Projects/gantt-lib && npm run build --filter packages/gantt-lib 2>&1 | tail -10
    All tests pass. Build succeeds with no TypeScript errors.
  </verify>
  <done>
    recalculateIncomingLags handles SS type: uses predecessorStartDate (not endDate),
    clamps to Math.max(0, lagDays). FS behavior unchanged. FF/SF pass through unchanged.
    All tests pass. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
After plan 01 completes:
1. Run npm test --filter packages/gantt-lib — all tests pass (including 7 new getSuccessorChain SS tests)
2. Run npm run build --filter packages/gantt-lib — no TypeScript errors
3. Verify getSuccessorChain signature in dependencyUtils.ts: third parameter linkTypes with default ['FS']
4. Verify recalculateIncomingLags in useTaskDrag.ts: SS branch uses predStart and Math.max(0, ...)
5. Existing callers of getSuccessorChain in useTaskDrag.ts (lines ~652 and ~498) still work without change (default parameter)
</verification>

<success_criteria>
- getSuccessorChain(id, tasks) still returns FS-only chain (backward compatible)
- getSuccessorChain(id, tasks, ['SS']) returns SS-only chain
- getSuccessorChain(id, tasks, ['FS','SS']) returns combined chain
- recalculateIncomingLags SS case: lag = max(0, startB - startA)
- recalculateIncomingLags FS case: unchanged (lag = startB - endA, no floor)
- All pre-existing tests pass
- Build is clean (no TypeScript errors)
</success_criteria>

<output>
After completion, create `.planning/phases/08-ss-dependency/08-01-SUMMARY.md`
</output>
